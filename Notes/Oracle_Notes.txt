
 oracle :- 

1  SQL (structured query language)
2  PL/SQL (procedural language/sql)

 Database :-
 ---------------

  => a  db is a organized collection of interrelated data. For example a univ
       db stores data related to students,courses and faculty and a bank db
       stores data related to customers,accounts,transactions and loans etc.

  Types of Databases :- 
  ------------------------------

  1  OLTP  DB (online transaction processing)
  2  OLAP DB (online analytical processing) 
 
   => organizations uses OLTP db for storing day-to-day transactions and OLAP
        for data analysis.

   => OLTP is for running business and OLAP is for to analyze business.

   => day-to-day operations on db includes 

         C   create
         R   read
         U   update
         D   delete

 DBMS :- 
 ------------

 => DBMS stands for Database management system and it is a software
      used to create and to manage database.

 =>  dbms is an interface between user and database.

 Evolution of DBMS :- 
 ---------------------------

  1960			FMS (File Mgmt System)

  1970			HDBMS (Hierarchical DBMS)
			NDBMS (Network DBMS)

  1980			RDBMS (Relational DBMS)

  1990			ORDBMS (Object Relational DBMS)

  RDBMS :- 
  -------------

  => RDBMS concepts introduced by E.F.CODD 
  => E.F.CODD introduced 12 rules called CODD rules
  => according to E.F.CODD in rdbms data must be organized in tables
       i.e rows and columns 

   CUSTOMERS
   CID   NAME    ADDR  => columns / fields / attributes
   10     SACHIN  HYD
   11     RAHUL    DEL
   12     VIJAY      MUM  => row / record / tuple

    Database  =   collection of tables
    Table         =   collection of rows & cols
    Row          =    collection of field values
    Column     =    collection of values belongs to one field

  => evert table must contain primary key to uniquely identify the records 
  
          ex :- accno,empid,aadharno,panno,voterid

05-dec-23

 RDBMS features :- 
 -------------------------

 1  easy to access and manipulate data 
 2  less redundency (duplication of data) 
 3  more security
 4  gurantees data quality
 5  supports data sharing
 6  supports transactions 

 RDBMS softwares :- 
 ------------------------------

 1   ORACLE                       from oracle corp
 2   MYSQL                         from oracle corp
 3   SQL SERVER              from microsoft
 4   DB2                              from ibm
 5   POSTGRESQL             from postgresql forum
 6   RDS                             from amazon

 ORDBMS :- 
 ----------------

   => Object Relational DBMS 
   => ORDBMS is combination of  rdbms & oops 
 
          ORDBMS  =   RDBMS  +  OOPS  (reusability)

  => RDBMS doesn't support reusability  but ORDBMS supports reusability 
  
  RDBMS :- 
  --------------

   CUST
   CID    NAME    HNO   STREET   CITY   STATE   PIN

   EMP
   EMPID  ENAME  HNO   STREET  CITY   STATE   PIN

 
 ORDBMS :- 
 -----------------

    UDT  :-     ADDR
                     HNO  STREET   CITY   STATE   PIN 
 
   CUST
   CID   CNAME    ADDR


   EMP
  EMPID   ENAME    ADDR


  ORDBMS softwares :- 
  ------------------------------

   ORACLE  upto 7 version   RDBMS
   ORACLE  from 8 version   ORDBMS 
   
 summary :- 

 what is db ?
 what is dbms ?
 what is rdbms ?
 what is ordbms ? 
  
 DB  Development Life Cycle :-  
 -----------------------------------------

 Analysis
 Design
 Development
 Testing
 Implementation
 Maintenance

 
Design :- 
------------

 => Designing db means designing tables 
 => db is designed by DB Designer / Architect 
 => db is designed by using

    1   ER Model  (Entity Relationship model)
    2   Normalization 

 Development :- 
 ----------------------

  => DB is developed by Developers by using  any rdbms tool like oracle 
  => DB development involves 

       CREATING TABLES
       CREATING VIEWS
       CREATING SYNONYMS
       CREATING SEQUENCES
       CREATING INDEXES
       CREATING PROCEDURES
       CREATING FUNCTIONS
       CREATING PACKAGES
       CREATING TRIGGERS 
       WRITING QUERIES

 Testing :- 
 -------------

   => DB is  tested by QA team (Quality Assurance) by using 

     1  manual  testing
     2  automation testing

 Implementation :- 
 ------------------------

   => Implementation means moving db from DEV server to PROD server 
   => once db is copied to PROD server end user can use db for day-to-day operations 

 ==============================================================
		
 			ORACLE
                                                 --------------

   => oracle is basically rdbms product and also supports ordbms features
        and used to manage database.

   => oracle is used  for db development  & administration

            Development                                 Administration

            creating tables                              installation of oracle 
            creating views                               creating database
            creating synonyms                        creating userids
            creating sequences                      db backup & restore
            creating indexes                           db export & import 
            creating procedures                     db upgradation & migration
            creating functions                         performance tuning
            creating packages
            creating triggers
            writing queries
             
                oracle  11     ======> oracle 21c          upgradation

                mysql    ==========> oracle               migration

  versions of oracle :- 
  ---------------------------

  Version  	         Year	            

Oracle v2,         1979		First commercially SQL-based RDBMS
Oracle v3,         1983		Concurrency control, data distribution, scalability
Oracle v4,         1984		Multiversion read consistency
Oracle v5,         1985	 	Client/server computing Support & distributed database systems
Oracle v6,         1988		Row-level locking, scalability, online backup and recovery, PL/SQL, Oracle Parallel Server
Oracle  7,         1992		                 PL/SQL stored procedures, Triggers, Shared Cursors, Cost Based Optimizer, Transparent Application Failover
Oracle  8i,        1997		                  Recovery Manager, Partitioning, Dataguard, Native internet protocols, Java, Virtual Private Database
Oracle  9i,          2001		                  Oracle Real Application Clusters (RAC), Oracle XML DB, Data Mining, Streams, Logical Standby
Oracle 10gR1,     2003		Grid infrastructure, Oracle ASM, Flashback Database, Automatic Database Diagnostic Monitor
Oracle 10gR2,      2005		Real Application Testing, Database Vault, Online Indexing, Advanced Compression, Transparent Data Encryption
Oracle 11gR1,      2007		Active Data Guard, Secure Files, Exadata
Oracle 11gR2,      2009		Data Redaction, Hybrid Columnar Compression, Cluster File System, Golden Gate Replication, Database Appliance
Oracle 12cR1,      2013		Multitenant architecture, In-Memory Column Store, Native JSON, SQL Pattern Matching, Database Cloud Service
Oracle 12cR2,      2016		Native Sharding, Zero Data Loss Recovery Appliance, Exadata Cloud Service, Cloud at Customer
Oracle 18c,        2018		Autonomous Database, Data Guard Multi-Instance Redo Apply, Polymorphic Table Functions, Active Directory Integration
Oracle 19c         2019		Automatic Indexing, Data-guard DML Redirect,Partitioned Hybrid Tables, Real-time Stats + Stats Only Queries
Oracle 21c         2021
Oracle 23c         2023

      2,3,4,5,6,7,8i,9i,10g,11g,12c,18c,19c,21c

                     i     =>   internet
                     g    =>    grid
                     c    =>     cloud

  => from 8 onwards oracle supports internet applications so suffix "i" is added.

  => grid means collection of servers , from version 10 onwards oracle db
       can be accessed through multiple servers called grid  and advantage of
       grid is even if one server is down we can access db through another server,
       so it improves availability. 

 =>  from 12c onwards oracle db can be deployed  in

       1 on premises
       2 on cloud

  =>  in " on premises "  db is deployed in the server managed by client
        
 => in  "  on cloud " db is deployed in the server managed by cloud service
      provide  for ex amazon. Cloud reduces initial investment for client.

07-dec-23

  CLIENT/SERVER Architecture :- 
  ------------------------------------------

  1 SERVER
  2 CLIENT 

  SERVER :- 
  ----------------

  => server is a system where  oracle software is installed and running.
  => inside the server oracle manages 

       1  DB
       2  INSTANCE

  => DB is created in hard disk and acts as permanent storage.
  => INSTANCE is created in ram and acts as temporary storage
  => data temporarly stored in instance and after saving it is copied to db.

 CLIENT :- 
 ---------------

  => client is also a system  from where users can

        1  connects to server
        2  submit requests to server
        3  receives response from server

  client tools :- 
  ------------------
  
 1 SQLPLUS   (CUI based)
 2 SQL DEVELOPER (GUI based) 

 USER------SQLPLUS--------------------------ORACLE-----------DB

SQL :- 
----------

 => SQL stands for strctured query language.
 => a language used to communicate with oracle.
 => user communicates with oracle by sending commands called queries.
 => a query is a command / instruction / question given to oracle to perform some
      operation over db.
 => SQL is originally introduced by IBM and initial name of this language was
      "sequel" and later it is renamed to sql
 => SQL is common to all rdbms databases 

      ORACLE       MYSQL         POSTGRESQL      DB2         SQL SERVER
         SQL              SQL                   SQL                 SQL           SQL

  USER----SQLPLUS-----------SQL---------------ORACLE--------DB
                 tool                       language          software        storage

   USER---MYSQLWORK----------SQL------------MYSQL-----------DB
                BENCH

   USER----SSMS----------------------SQL-----------SQL SERVER-------DB

=> based on operations over db sql is categorized into following sublanguages

       DDL (DATA DEFINITION LANG)
       DML (DATA MANIPULATION LANG)
       DQL (DATA QUERY LANG)
       TCL  (TRANSACTION CONTROL LANG)
       DCL  (DATA CONTROL LANG) 

 			SQL

             DDL	DML	DQL	TCL		DCL

            create	insert	select	commit		grant
            alter	update		rollback		revoke
            drop	delete		savepoint
            truncate	insert all
            rename	merge
            flashback
            purge
 
 DATA & DATA DEFINITION :- 
 ----------------------------------------

  EMPID	ENAME	SAL    => DATA DEFINITION / METADATA 
  1	A	6000   => DATA
 
SCHEMA :- 
----------------

 => a user in oracle db is called schema 

     SERVER
              DATABASE
                          USER
                                TABLE 
                                      DATA

     SERVER
             ORCL
                  SYS / TIGER                    (DBA)
                  SYSTEM / TIGER             (DBA)

  How to connect to oracle :- 
  -------------------------------------
                   
  => to connect to oracle open sqlplus and enter username and password

               USERNAME   :-    SYSTEM
               PASSWORD  :-     TIGER

              OR

              USERNAME :-   SYSTEM / TIGER 

 08-dec-23

 creating user/schema/account  in oracle db :- 
 -------------------------------------------------------------

 =>  only DBA is having permissions to create new user.

  STEP 1 :-  connect as DBA

           USERNAME  :-   SYSTEM/TIGER

  STEP 2 :-   create  user

     syn :- 

     CREATE USER <NAME> IDENTIFIED BY <PWD>
     DEFAULT TABLESPACE USERS
     QUOTA UNLIMITED ON USERS ;

   ex :- 
 
   SQL>CREATE USER BATCH27 IDENTIFIED BY ORACLE
            DEFAULT TABLESPACE USERS
            QUOTA UNLIMITED ON USERS ; 

 STEP 3 :-  granting permissions to user
 
     SQL>GRANT CONNECT,RESOURCE TO BATCH27 ; 

                    CONNECT  =>  to connect to db
                    RESOURCE => to create tables 
                    DBA              => all permissions 

  changing password :- 
  ------------------------------

 => both user and dba can change password 

 BY USER :-    (BATCH27/ORACLE)
 ---------------

SQL>PASSWORD
Changing password for BATCH27
Old password: ORACLE
New password: NARESH
Retype new password: NARESH
Password changed

BY DBA :-    (SYSTEM/TIGER)
---------------

SQL>ALTER USER BATCH27 IDENTIFIED BY ORACLE ; 

 SERVER
        ORCL
               SYS
               SYSTEM
               BATCH27 

 Datatypes in oracle :- 
 -----------------------------

  => a Datatype specifies
 
 1   what type of  data allowed 
 2   how much memory allocated

		            DATATYPES

             CHAR                      NUMERIC          DATE              BINARY

 ASCII          UNICODE         number(p)          date                 bfile
                                             number(p,s)        timestamp       blob
 char	     nchar
 varchar2       nvarchar2
 long              nclob
 clob
 
 CHAR(size) :-  
 --------------------

   => allows character data upto 2000 chars
   => recommended for fixed length char fields

      ex :-   NAME    CHAR(10) 
 
                sachin----
                             wasted
                
                ravi------
                           wasted

   => in char datatype extra bytes are wasted , so char is not recommended
        for variable length fields and char is recommended for fixed length fields

                 GENDER             CHAR(1)

                 M
                 F

                 STATE_CODE     CHAR(2)

                 AP
                 TS
                 
VARCHAR2 :- 
 -------------------

   => allows character data upto 4000 chars
   => recommended for variable length fields 

      ex :-    NAME        VARCHAR2(10)

                 sachin----
                              released 

 => char/varchar2 allows ascii chars (256 chars) that includes a-z,A-Z,0-9
      and special chars 

        ex  :-      PANNO     CHAR(10)
                      VEHNO     CHAR(10)
                      EMAILID   VARCHAR2(20) 
       
 LONG :- 
 -------------
 
   => allows character data upto 2GB 

      ex :-  review    long

 CLOB  :-      (character large object)
 --------------

 => allows characrter data upto 4GB 
 
     ex ;-  text     CLOB  

NCHAR / NVARCHAR2 / NCLOB :-   (N  => National) 
-----------------------------------------------

=> allows unicode chars (65536) that includes all ascii chars and chars
     belongs to different languages.

 NUMBER(P) :- 
 --------------------

   => allows numeric data upto 38 digits (integers)

    ex :-    empid    NUMBER(4) 

               10
               100
               1000
               10000  => NOT ALLOWED 

                 aadharno    NUMBER(12)
                 phone         NUMBER(10)
                 accno          NUMBER(11)


  NUMBER(P,S) :- 
  -----------------------

   => allows numbers with decimal (float) 

     P     => precision => total no of digits allowed
     S     => scale      =>  no of digits allowed after decimal

    ex  :-     SAL       NUMBER(7,2) 

                 5000
                 5000.55
                 50000.55
                 500000.55  => NOT ALLOWED 

                    5000.5678      => ALLOWED =>  5000.57
                    5000.563478  => ALLOWED => 5000.56

  NOTE :-  if before decimal exceeds number is not accepted
                 if after decimal exceeds number is rounded 
  
                    SAVG      NUMBER(5,2)

09-DEC-23 

 DATE :- 
------------

  => allows date & time
  => time is optional , if not entered oracle stores 12:00 AM
  => default date format in oracle is DD-MON-YY / YYYY
 
    EX :-       DOB         DATE

                   15-MAR-03    => 15-MAR-2003
                   05-OCT-98    =>  05-OCT-2098
                   05-OCT-1998  

 => a date occupies 7 bytes 

      input  :-  DD-MON-YYYY

      stores :-  DD MM  YYYY  HH  MI  SS 
                     1    1      2         1      1    1           

TIMESTAMP :- 
--------------------

  => timestamp allows date , time and milliseconds
  
      ex :-    T          TIMESTAMP

                 09-DEC-23  14:41:20.12356789
                 --------------   -----------   -------
                     DATE       TIME        MS

 => depends on milliseconds timestamp occupies 9 to 13 bytes 

Binary Types :- 
 --------------------

  => Binary Types includes multimedia objects like audio,video,images
  => oracle supports 2 binary types 

  1  BFILE (Binary File)
  2  BLOB (Binary Large Object) 

 => BFILE is called external lob because lob stored outside db but db stores path
 => BLOB is called interanl lob because lob stored inside db 
 => if security is not required then use BFILE 
 => if security is required then use BLOB

 ==========================================================================

 DOWNLOAD & INSTALL :- 
 -----------------------------------

 DOWNLOAD :- 
 ----------------------

 https://www.oracle.com/database/technologies/xe-downloads.html

STEP BY STEP INSTALLATION ;-  
----------------------------------------------

 https://www.programsbuzz.com/article/install-oracle-xe-21c-windows-10

CREATING TABLE IN ORACLE DB :- 
---------------------------------------------------

 CREATE TABLE <TABNAME>
 (
    COLNAME  DATATYPE(SIZE),
    COLNAME  DATATYPE(SIZE),
     --------------------------------------,
     -----------------------------
  );

 Rules for creating table :- 
 ----------------------------------

 1  tabname should start with alphabet
 2  name should not contain spaces & special chars but allows   _   $   # 
 3  name can be upto 128 chars 
 4  table can have max 1000 cols 
 5  no of rows unlimited 

  ex :-    123EMP         INVALID
             EMP 123        INVALID
             EMP*123       INVALID
             EMP_123      VALID

Example :- 

 => create table with following structure ?

     EMP
     EMPID   ENAME   JOB   SAL    HIREDATE     DNO 

    CREATE TABLE EMP
    (
        EMPID    NUMBER(4) ,
        ENAME   VARCHAR2(10),
        JOB         VARCHAR2(10),
        SAL          NUMBER(7,2),
        HIREDATE DATE,
        DNO           NUMBER(2)
    ) ;

     above command created table structure that includes columns,datatype and size .

DESC :-    (DESCRIBE)
------------
        
=> command used to see the structure of the table.

                     DESC   <tabname> ;
 
   EX :- 
 
          SQL>DESC  EMP ; 

 	EMPID                             NUMBER(4)
 	ENAME                           VARCHAR2(10)
 	JOB                                 VARCHAR2(10)
 	SAL                                  NUMBER(7,2)
 	HIREDATE                       DATE
 	DNO                                 NUMBER(2)

 INSERTING DATA INTO TABLE :- 
 ----------------------------------------------

 => "INSERT" command is used to insert data (row) into table.
 =>  we can insert

    1 single row
    2 multiple rows 

 inserting single row :- 
 ---------------------------

      INSERT INTO <TABNAME> VALUES(V1,V2,V3,----------) ; 
 
 EX :- 
 
SQL>INSERT INTO EMP VALUES(100,'SACHIN','CLERK',5000,'09-DEC-23',10);
SQL>INSERT INTO EMP VALUES(101,'ARVIND','MANAGER',8000,SYSDATE,20);

 above insert commands inserted data into instance (ram) , to save this data execute COMMIT

  SQL>COMMIT ; 

  after COMMIT data copied to DB  

11-dec-23 

 inserting multiple rows :- 
 ----------------------------------

 => insert command can be executed multiple times with different values
      by using variables prefixed with "&".

 ex :-  

  SQL>INSERT INTO EMP 
                    VALUES(&EMPID,&ENAME,&JOB,&SAL,&HIREDATE,&DNO);

Enter value for empid: 102
Enter value for ename: 'VIJAY'
Enter value for job: 'ANALYST'
Enter value for sal: 6000
Enter value for hiredate: '15-JAN-20'
Enter value for dno: 30

 1 row created

 SQL>  /     (previous command reexecuted)

 Enter value for empid: 103
Enter value for ename: 'RAJU'
Enter value for job: 'CLERK'
Enter value for sal: 4000
Enter value for hiredate: '5-OCT-19'
Enter value for dno: 20
 
1 row created 

inserting nulls :- 
----------------------

  =>  a  null means blank or empty
  =>  it is not equal to 0 or space
  => nulls can be inserted in two ways 

   method 1 :-  
   -----------------

   SQL>INSERT INTO EMP 
                       VALUES(104,'SATISH','',NULL,'20-APR-21',30);

  method 2 :-
  -----------------

  SQL> INSERT INTO EMP(EMPID,ENAME,HIREDATE,DNO)
                       VALUES(105,'KUMAR',SYSDATE,10);

   remaining two fields job,sal are filled with nulls 

  Operators in ORACLE :- 
  ---------------------------------

  1   Arithmetic Operators   =>    +   -    *      /    
  2   Relational Operators   =>    >   >=    <    <=    =     <>    !=
  3   Logical Operators       =>    AND  OR   NOT 
  4   Special Operators       =>   BETWEEN
                                                  IN
                                                  LIKE
                                                  IS
                                                  ANY
                                                  ALL
                                                  EXISTS
                                                  PIVOT
   5  Set Operators               => UNION
                                                  UNION ALL
                                                  INTERSECT
                                                  MINUS

  Displaying Data :- 
  --------------------------

  => "SELECT"  command  is used to display data from table
  =>  we can display all rows or specific rows
  =>  we can display all cols or specific cols 

             SELECT  COLUMNS / *    FROM   TABNAME  ; 

                            SQL         =       ENGLISH 
                           QUERIES =      SENTENCES
                          CLAUSES  =     WORDS

   => display employee names and salaries ? 

         SELECT ENAME,SAL FROM EMP ; 

   => display employee ids and hiredates ? 

       SELECT  EMPID,HIREDATE FROM EMP ; 

   => display all the data from emp ? 

      SELECT  * FROM EMP ; 
 
           *    => all columns 

WHERE clause :- 
-------------------------

=> used to get specific row/rows from table based on a condition

       SELECT columns / * 
       FROM tabname
       WHERE condition ; 
 
 condition :- 
 -------------

                                  COLNAME   OP    VALUE 

  => OP must be  any relational operator like    =   >    >=    <     <=    <>  !=
  => if cond = true row is selected
  => if cond = false row is not selected 
                                  
   Ex :- 

   =>  display employee details whose id = 103 ? 

         SELECT *  FROM EMP  WHERE  EMPID = 103 ; 
         
   => display employee 103 name & salary ? 

        SELECT ENAME,SAL  
        FROM EMP
        WHERE EMPID = 103 ; 

   => employee details whose name is KUMAR ? 

      SELECT *
      FROM EMP
      WHERE ENAME = 'KUMAR' ; 

      SELECT *
      FROM EMP
      WHERE ENAME = 'kumar' ;   =>   no rows 

   NOTE :-  

     string comparision is case sensitive i.e. uppercase and  lowercase strings are not same.

    => employees earning more than 5000 ? 

        SELECT * FROM EMP WHERE SAL > 5000 ; 

    => employees joined after 2020  ? 

       SELECT * FROM EMP WHERE HIREDATE > 2020 ;   => ERROR
 
       SELECT * FROM EMP WHERE HIREDATE > '31-DEC-2020' ;
  
   => employees joined before 2020 ? 

             SELECT * FROM EMP WHERE HIREDATE  < '01-JAN-2020'  ; 

  => employees not working for dept 30 ? 

          SELECT * FROM EMP WHERE  DNO <> 30 ; 

12-DEC-23 

 compound condition :- 
 -------------------------------

  => multiple conditions combined with AND / OR operators called compound
       condition.

      WHERE  COND1   AND   COND2           RESULT
                       T		T	    T
	       T		F	    F
                        F		T	    F
                        F		F	    F

      WHERE  COND1  OR   COND2            RESULT
                       T                     T                        T
                       T                     F                        T
                       F                    T                         T
                       F                    F                        F 

  => employees whose id = 100,103 ? 

      SELECT * FROM EMP  WHERE EMPID = 100  OR EMPID = 103 ;     

 => employees working as clerk,manager ?

     SELECT * FROM EMP WHERE JOB='CLERK'  OR  JOB='MANAGER' ; 
 
 => employees working for 20th dept and working as clerk ? 

    SELECT * FROM EMP WHERE DNO = 20 AND JOB = 'CLERK'  ;

  => employees earning more than 5000 and less than 10000 ?

    SELECT * FROM EMP WHERE SAL > 5000 AND  SAL < 10000 ; 

 => employees joined in 2020 ? 

     SELECT * FROM EMP WHERE HIREDATE  >= '01-JAN-2020'
                                                        AND
                                                        HIREDATE <= '31-DEC-2020'  ; 

 => 

   STUDENT
   SNO  SNAME   S1   S2    S3
   1       A             80     90    70
   2       B            30     60    50

  list of students who are passed  ?

  SELECT * FROM STUDENT WHERE S1>=35  AND   S2>=35  AND  S3>=35  ;   

  list of students who are failed ?

  SELECT * FROM STUDENT WHERE  S1<35   OR   S2<35   OR   S3<35  ; 

=> employees working as clerk,manager and earning more than 5000 ? 

    SELECT *
    FROM EMP 
    WHERE  JOB='CLERK'
                   OR
                   JOB='MANAGER'
                   AND
                   SAL > 5000 ; 

  above query returns clerks earning less than 5000 because operator AND 
  has got more priority than operator OR  and SAL > 5000 is applied only to
  MANAGER but not to CLERK , to overcome this problem use (    ) 

    SELECT *
    FROM EMP 
    WHERE  (
                   JOB='CLERK'
                   OR
                   JOB='MANAGER'
                   )
                   AND
                   SAL > 5000 ; 

   IN operator :- 
   -------------------- 

   => use IN operator for list comparision 
   => use IN operator for "=" comparision with multiple values 

         WHERE   COLNAME =  V1,V2,V3,--          INVALID

         WHERE   COLNAME  IN (V1,V2,V3,--)      VALID

  Ex :- 

  => employees working as clerk,manager,analyst ? 

      SELECT *
      FROM EMP 
      WHERE JOB IN ('CLERK','MANAGER','ANALYST') ; 

  => employees not working for dept 10,20 ? 

       SELECT *
      FROM EMP 
      WHERE  DNO NOT IN (10,20)  ;

 BETWEEN operator :- 
 -------------------------------

 => use BETWEEN operator for range comparision 

      WHERE COLNAME  BETWEEN V1 AND V2  (COL>=V1 AND COL<=V2) 

 => employees earning between 5000 and 10000 ? 
 
     SELECT *
     FROM EMP
     WHERE SAL BETWEEN 5000 AND 10000 ; 

 => employees not joined in 2020 ? 

    SELECT *
    FROM EMP
    WHERE HIREDATE NOT BETWEEN '01-JAN-2020' AND '31-DEC-2020'  ;

Question :- 

 SELECT *
 FROM EMP
 WHERE SAL BETWEEN 10000 AND 5000 ;

A  ERROR
B  RETURNS NO ROWS
C  RETURNS ROWS
D  NONE 

 ANS :-  B

 WHERE SAL BETWEEN 5000 AND 10000  (SAL>=5000 AND SAL<=10000)
 WHERE SAL BETWEEN 10000 AND 5000 (SAL>=10000 AND SAL<=5000) 

  NOTE :- use BETWEEN with lower and upper
 
 => employees working as clerk,manager and earning between 5000 and 10000
      and not joined in 2020 and not working for dept 20,30 ? 

      SELECT *
      FROM EMP 
      WHERE  JOB IN ('CLERK','MANAGER')
                     AND
                     SAL BETWEEN 5000 AND 10000
                     AND
                     HIREDATE NOT BETWEEN '01-JAN-2020' AND '31-DEC-2020'
                     AND
                     DNO NOT IN (20,30) ; 

 => list of samsung,redmi,realme mobile phones price between 10000 and 20000 ?

  PRODUCTS
  prodid  pname   price    category    brand

  SELECT *
  FROM PRODUCTS 
  WHERE   PRICE BETWEEN 10000 AND 20000  
                 AND
                 BRAND IN ('SAMSUNG','REDMI','REALME')
                 AND
                 CATEGORY='MOBILES' ;

=> list of male customers staying in hyd,blr,mum age between 30 and 40 ? 

  CUST
  CID   NAME   GENDER   AGE   CITY

  SELECT *
  FROM CUST
  WHERE GENDER='M'
                AND
                CITY IN ('HYD','BLR','MUM')
                AND
                AGE BETWEEN 30 AND 40 ; 

13-dec-23 

 LIKE operator :-
 ----------------------

  => use LIKE operator for pattern comparision 
 
     ex :-  name starts with 's'
              emailid ends with '.in'
              
          WHERE   COLNAME   LIKE   'PATTERN' 

 => pattern consists of alphabets,digits,special chars and wildcard chars 

  wildcard chars :- 
  -----------------------

                     %     =>  0 or many chars

                     _      =>  exactly 1 char
 
 => employees name starts with 'S'  ? 

     SELECT * FROM EMP WHERE ENAME LIKE 'S%'  ; 

 => name ends with 'D'  ? 	

     SELECT * FROM EMP WHERE ENAME LIKE '%D' ;

 => name contains 'A' ? 

     SELECT * FROM EMP WHERE ENAME LIKE '%A%' ; 

 => where 'A' is the 2nd char ? 

       SELECT * FROM EMP WHERE ENAME LIKE '_A%' ;

 => 'A' is the 2nd char from last ? 

      SELECT * FROM EMP WHERE ENAME LIKE '%A_' ;

=> name contains 5 chars ? 

     SELECT * FROM EMP WHERE ENAME LIKE '_____'  ; 

=> employees joined in jan month ?    DD-MON-YY

    SELECT * FROM EMP WHERE HIREDATE LIKE '%JAN%' ; 

    SELECT * FROM EMP WHERE HIREDATE LIKE '___JAN___' ;

=> who are joined in 2020 ? 
 
   SELECT * FROM EMP WHERE HIREDATE LIKE '%20' ; 

 Question :- 

  SELECT *
  FROM EMP 
  WHERE  JOB IN ('CLERK','MAN%') ;

  A  ERROR 
  B  RETURNS CLERK,MANAGER
  C  RETURNS ONLY CLERK
  D  NONE 

  ANS :-   C 

  WHERE JOB='CLERK'  OR  JOB LIKE 'MAN%'   ;

 ANS :-  B 

=> list of customers  name contains "_"   ? 

  CUST
  CID	CNAME
  10	sachin_tendulkar
  11	virat%kohli
  12	mahendra_singh_dhoni

  SELECT * FROM CUST WHERE CNAME LIKE '%_%'  ; 

 above query returns all records because "_" is not treated as normal char
 and it is treated as wildcard char , to overcome this problem use escape char

  SELECT * FROM CUST WHERE CNAME LIKE '%\_%'   ESCAPE  '\' ;

  char that immediately follows "\" is treated as normal char and not treated as 
  wildcard char

  => name contains "%"  ? 

   SELECT * FROM CUST WHERE CNAME LIKE '%\%%'  ESCAPE '\' ;

 => name contains 2 "_"  ? 

   SELECT * FROM CUST WHERE CNAME LIKE '%\_%\_%'   ESCAPE '\' ;

IS operator :- 
--------------------

  => use IS operator for  NULL comparision

             WHERE COLNAME IS NULL
             WHERE COLNAME IS NOT NULL

  => employees not earning salary ? 

    SELECT * FROM EMP WHERE SAL IS NULL ; 
 
  => who are earning salary ? 

     SELECT * FROM EMP WHERE SAL IS NOT NULL ; 

 summary :- 

  WHERE COL  IN (V1,V2,V3,---)
  WHERE COL BETWEEN V1 AND V2
  WHERE COL LIKE 'PATTERN'
  WHERE COL IS NULL 
 
=> display ENAME  ANNUAL SAL  ? 

    SELECT ENAME,SAL*12
    FROM EMP ; 

ALIAS :- 
------------

 => alias means another name or alternative name
 => used to change column heading

            COLNAME / EXPR  [AS]  ALIAS 

   Ex :- 

    => display  ENAME   ANNUAL SAL ? 

        SELECT ENAME,SAL*12 AS ANNSAL  FROM EMP ; 

        SELECT ENAME,SAL*12 AS "ANNUAL SAL"  FROM EMP ; 

  => display ENAME   EXPERIENCE  ? 

       SELECT  ENAME,  (SYSDATE-HIREDATE)/365   AS EXPR 
        FROM EMP ;

  => display ENAME  SAL   HRA   DA   TAX    TOTSAL   ? 

             HRA = house rent allowance  =   20% on sal
             DA   = dearness allowance   =   30% on sal
             TAX = 10% on sal 
             TOTSAL = SAL + HRA + DA - TAX 

    SELECT ENAME,SAL,
                   SAL*0.2 AS HRA,
                   SAL*0.3 AS DA,
                   SAL*0.1 AS TAX,
                   SAL + (SAL*0.2) + (SAL*0.3) - (SAL*0.1)  AS TOTSAL   
  FROM EMP ;

  SACHIN    5000      1000        1500       500       7000

=> list of tables created by user ? 

    SELECT  TABLE_NAME FROM USER_TABLES ; 

 => list of users ? 

    SELECT USERNAME FROM ALL_USERS ; 
 
14-dec-23 

  DML commands :-  (Data Manipulation Lang)
  -----------------------

  INSERT
  UPDATE
  DELETE
  INSERT ALL
  MERGE 

 => all DML commands acts on table data
 => DML operations are performed on instance.
 => to save  the operation use commit
 => to cancel the operation use rollback

 UPDATE command :- 
 -------------------------------

 => command used to modify table data.
 => we can update all rows or specific rows.
 => we can update single column or multiple columns.

   UPDATE <tabname>
   SET colname =  value  ,   colname =  value ,---------------
   [WHERE cond] ; 

 ex :- 

  => update all employees comm with 500 ? 

     UPDATE EMP  SET  COMM = 500  ;

 => update employees comm with 500 whose comm = null  ? 

     UPDATE EMP SET COMM = 500 WHERE COMM IS  NULL ;  

 => update comm with null whose comm <> null  ? 

    UPDATE EMP SET COMM = NULL WHERE COMM IS NOT NULL ; 

                NULL assignment    = 
                NULL comparisioN  IS 

  => increment sal by 20% and comm by 10% those working as salesman and joined in 1981 year ?

     UPDATE EMP 
     SET SAL = SAL +  (SAL*0.2) , COMM = COMM + (COMM*0.1) 
     WHERE  JOB='SALESMAN'
                    AND
                   HIREDATE  LIKE '%81'  ;

=>  increase samsung,redmi,realme mobile phones price by 10% ? 

  PRODUCTS
  PROID  NAME   PRICE   CATEGORY  BRAND

  UPDATE PRODUCTS 
  SET PRICE = PRICE+ (PRICE*0.1) 
  WHERE  BRAND IN ('SAMSUNG','REDMI','REALME')
                  AND
                  CATEGORY='MOBILES'  ; 

 DELETE command :- 
 -----------------------------

  => command used to delete row/rows from table
  => we can delete all rows or specific rows
  
   DELETE FROM <TABNAME>  [WHERE COND] ; 

 Ex :- 

 => delete employees having more than 40 years for expr ?   

     DELETE FROM EMP WHERE  (SYSDATE - HIREDATE)/365  > 40  ; 

 => delete all rows from emp ? 

     DELETE FROM EMP ; 

DDL commands :-     (Data Definition Lang)
------------------------

 CREATE
 ALTER
 DROP
 TRUNCATE
 RENAME
 FLASHBACK
 PURGE

 => all DDL commands acts on table structure (columns,datatype and size).
 => all DDL commands are auto committed.

             DDL command =  DDL command + commit 

Question 1 :- 
  
 CREATE TABLE A(A  NUMBER(2));
 INSERT INTO A VALUES(10);
 INSERT INTO A VALUES(20);
 ROLLBACK ; 

 CREATE TABLE  => SAVED
 INSERT 10,20    => CANCELLED

 Question 2 :- 

CREATE TABLE A(A  NUMBER(2));  =>  commit
 INSERT INTO A VALUES(10);
 INSERT INTO A VALUES(20);
 CREATE TABLE B(B NUMBER(2));  => commit
 INSERT INTO A VALUES(30);
 INSERT INTO A VALUES(40);
 ROLLBACK;                                     => cancelled

15-dec-23 

ALTER command :- 
----------------------------

  => command used to modify table structure
  => using alter we can 

      1 add columns
      2 drop columns
      3 rename column
      4 modify column 
              changing size
              changing datatype

 Adding columns :- 
 ------------------------

 => add column gender to emp table ? 

     ALTER TABLE EMP
            ADD (GENDER   CHAR(1)); 

    after adding use update command to insert data into the column 

   1   UPDATE EMP SET GENDER = 'M'  WHERE EMPNO = 7369 ; 

   2   UPDATE EMP SET GENDER = &GENDER WHERE EMPNO = &EMPNO ; 

 Droping column :- 
 ------------------------

 => drop column gender from emp ? 

      ALTER TABLE EMP
           DROP (GENDER ) ;

Renaming a column :- 
-----------------------------

 => rename column comm to bonus ? 

     ALTER TABLE EMP
            RENAME  COLUMN COMM TO BONUS ; 

  
    SELECT ENAME,SAL,COMM AS BONUS FROM EMP ; 

     difference between rename & alias ?

               rename                                  alias 
 
 1     permanent		          temporary

 2     changes name of	          changes column
        the column in table                      heading in select stmt output

 Modifying a column :- 
 -----------------------------

  1  changing size
  2  changing datatype

  => increase the size of ename to 20 ? 

    ALTER TABLE EMP
              MODIFY (ENAME  VARCHAR2(20));

  NOTE :- 

   column must be empty to change datatype 

   ALTER TABLE EMP
        MODIFY (EMPNO  VARCHAR2(10));   => ERROR

   How to change datatype , if column is not empty  ?

  STEP 1 :-  add new column empid

     ALTER TABLE EMP
              ADD (EMPID   VARCHAR2(10)); 

  STEP 2 :-  copy data from empno to empid 

    UPDATE EMP SET EMPID = 'TCS'||EMPNO  ;
    
   STEP 3 :- remove column empno

    ALTER TABLE EMP 
             DROP (EMPNO) ;                       

   STEP 4 :-  rename column empid to empno 

     ALTER TABLE EMP
              RENAME  COLUMN EMPID TO EMPNO ; 

  Drop command :- 
 ----------------------------

   => command used to drop table from db
   => drops table structure along with data

             DROP TABLE <TABNAME>  ;

  Ex :- 

     SQL>DROP TABLE EMP ; 

  => after droping the table , it is moved to recyclebin , to see the recyclebin            
       execute following command

      SQL>SHOW RECYCLEBIN  ;

       EMP

  FLASHBACK command :- 
  ------------------------------------

   => command used to restore the table from recyclebin.

         FLASHBACK TABLE <TABNAME> TO BEFORE DROP ; 

 Ex :- 

   SQL>FLASHBACK TABLE EMP TO BEFORE DROP ; 

 => table is restored with column and rows that exists before drop . 

 PURGE command :- 
 ----------------------------

  => command used to delete table from recyclebin.
  => after deleting table from recyclebin we cannot flashback the table.

              PURGE TABLE <TABNAME>

  ex :- 

      SQL>PURGE TABLE EMP ; 
    
TRUNCATE command :- 
-----------------------------------

  => deletes all the data from table.
  => will empty the table.
  => releases memory allocated for table.

              TRUNCATE TABLE <TABNAME> ;

  ex :- 

         SQL>TRUNCATE TABLE CUST ; 

   => oracle goes to memory and releases all the blocks allocated for table ,
        when blocks are released data stored in blocks also deleted.

 DELETE VS TRUNCATE :- 
 -------------------------------------

            DELETE			TRUNCATE

 1        DML command		DDL command

 2       can delete all rows                           can delete only all rows
          and specific rows                             but cannot delete specific rows

 3      where cond can be                           where cond cannot be 
         used with delete                               used with truncate

  4     operation can be                              operation cannot be
         rolledback                                        rolledback

   5    deletes row-by-row                           deletes all rows at a time

   6    slower                                               faster

   7    will not release memory                    releases memory 

 RENAME :- 
 ----------------

  => command used to change name of the table

            RENAME  <oldname> TO <newname> 

  EX :- 

       SQL>RENAME CUST TO CUSTOMERS ; 

 Built-in Functions in oracle :- 
 --------------------------------------
 
 => a function accepts some input performs some calculation and returns one value

 Types of functions :- 
 -----------------------------

  1  character
  2  numeric
  3  date
  4 conversion
  5 special
  6 analytical
  7 group / aggregate

  character functions :- 
  -----------------------------

  1 UPPER() :- 
     --------------
 
 => converts string to uppercase 

           UPPER(string / colname)

    Ex :- 

    SQL>SELECT  UPPER('hello')   FROM  DUAL ;   => HELLO

    DUAL is a dummy table provided by oracle used to select non db values 

 LOWER() :- 
 -----------------

   => converts string to lowercase 

              LOWER(string/colname) 

  SQL> SELECT LOWER('HELLO')  FROM DUAL ;   => hello 

 => display   EMPNO  ENAME  SAL  ? display names in lowercase ? 

      SELECT EMPNO,LOWER(ENAME) AS ENAME,SAL FROM EMP ; 

 => convert names to lowercase in table ? 

     UPDATE EMP SET ENAME = LOWER(ENAME) ; 

=> display employee details whose name = BLAKE  ? 

     SELECT * FROM EMP WHERE ENAME = 'BLAKE'  ;  => no rows 
  
     in oracle by default string comparision is case sensitive i.e. lowercase strings
     and uppercase strings are not same , to do case insensitive comparision
     use UPPER / LOWER functions 
  
     SELECT * FROM EMP WHERE UPPER(ENAME) = 'BLAKE'  ; 

     SELECT * FROM EMP WHERE LOWER(ENAME) = 'blake'  ; 
   
  INITCAP() :- 
  -----------------

   =>  converts initials into capitals 

           INITCAP(string/colname) 

  Ex :-  

  SQL>SELECT INITCAP('hello welcome') FROM DUAL ; 

            o/p :-  Hello Welcome

 LENGTH() :- 
 ------------------

  => returns string length i.e. no of chars 

           LENGTH(string/colname) 

   Ex :- 

  SQL>SELECT LENGTH('hello welcome') FROM DUAL ;  => 13

 =>  display employee name contains 4 chars ? 

     SELECT * FROM EMP WHERE LENGTH(ENAME) =  4 ;  

  SUBSTR() :- 
  ------------------

   => returns part of the string

               SUBSTR(string,start,[no of chars])

  Ex :- 

    SUBSTR('HELLO WELCOME',1,5)    =>   HELLO
    SUBSTR('HELLO WELCOME',7,4)    =>   WELC
    SUBSTR('HELLO WELCOME',7)       =>   WELCOME

     SUBSTR('HELLO WELCOME',-6,3)   =>   ELC 
     SUBSTR('HELLO WELCOME',-7)     =>    WELCOME

 => employees name starts with 's' ? 

     SELECT * FROM EMP  WHERE SUBSTR(ENAME,1,1)  =  's'  ;

 => employee name ends with 's' ? 

    SELECT * FROM EMP  WHERE SUBSTR(ENAME,-1,1)  =  's'  ;

  => employees name starts and ends with same char  ? 

        SELECT * FROM EMP  WHERE  ENAME LIKE 'a%a'
                                                             OR
                                                              ENAME LIKB 'b%b'
                                                              OR
        SELECT * 
        FROM EMP
        WHERE SUBSTR(ENAME,1,1)  =  SUBSTR(ENAME,-1,1) ;

 => generate emailids for employees as follows ? 
 
      EMPNO	ENAME		EMAILID
      7369		smith		smi736@tcs.com
      7499                    allen                          all749@tcs.com

     SELECT EMPNO,ENAME,
              SUBSTR(ENAME,1,3)||SUBSTR(EMPNO,1,3)||'@tcs.com' AS EMAILID
     FROM EMP ; 

    => store emailids in db ? 
 
    step 1 :- add emailid column to emp table

     ALTER TABLE EMP 
         ADD (EMAILID   VARCHAR2(20)); 

    step 2 :- update column with emailids 

     UPDATE EMP 
     SET EMAILID = SUBSTR(ENAME,1,3)||SUBSTR(EMPNO,1,3)||'@tcs.com'  ;
      
LPAD & RPAD :- 
-----------------------

  => both functions used to fill string with a character 

            LPAD(string,length,char)      => fills left side
            RPAD(string,length,char)     => fills right side 

  EX :- 

     LPAD('HELLO',10,'*')                 =>   *****HELLO
     RPAD('HELLO',10,'*')                =>    HELLO*****
     RPAD('*',10,'*')                          =>    **********
 
18-dec-23 

 => display ENAME	SAL  ?
		***
		****
        
    SELECT ENAME,RPAD('*',LENGTH(SAL),'*') AS SAL FROM EMP ; 		
  
=>

 ACCOUNTS
 ACCNO	   	BAL
 12345678962	10000

your a/c no  XXXX8962 debited 1000 ------ ? 

 METHOD 1 :-   LPAD('X',4,'X')||SUBSTR(ACCNO,-4,4)

 METHOD 2 :-   LPAD(SUBSTR(ACCNO,-4,4),8,'X') 

LTRIM,RTRIM,TRIM :- 
------------------------------

 => used to remove spaces and unwanted chars 

          LTRIM(str,[char])   => removes left side
          RTRIM(str,[char])  => removes right side
          TRIM(str)              => removes both sides 

 Ex :-

     LTRIM('   HELLO    ')        =>  'HELLO     '
     RTRIM('  HELLO   ')         =>  '     HELLO'
     TRIM('     HELLO  ')          =>  'HELLO'

     LTRIM( '@@@HELLO@@@','@')   		 =>    HELLO@@@
     RTRIM( '@@@HELLO@@@','@')    		=>    @@@HELLO
     TRIM(BOTH '@' FROM '@@@HELLO@@@')     => HELLO
  
   NAME       CHAR2(10) 

   SRINIVAS--

 REPLACE() :- 
 -------------------

  => used to replace one string with another string
 
                  REPLACE(str1,str2,str3) 

    ex :- 

      REPLACE('HELLO','ELL','ABC')        =>  HABCO 
      REPLACE('HELLO','L','ABC')            =>  HEABCABCO
      REPLACE('HELLO','ELO','ABC')       =>  HELLO

      REPLACE('@@HE@@LL@@O@@','@','')  => HELLO 

    => display employees name contains exactly 1 'a'  ? 

        SELECT * FROM EMP WHERE ENAME LIKE '%a%'  ; 
  
        SELECT *
        FROM EMP
        WHERE LENGTH(ENAME) - LENGTH(REPLACE(ENAME,'a','')) = 1 ;
                         
 TRANSLATE() :- 
 ----------------------

  => used to translate one char to another char

               TRANSLATE(str1,str2,str3) 

  ex :- 

   TRANSLATE('HELLO','ELO','ABC')   =>  HABBC 

                      E  =>  A
                      L  =>  B
                      O  => C

    TRANSLATE('HELLO','ELO','')           =>  NULL 

 => TRANSLATE function can be used to encrypt data i.e. converting plain text
      to cipher text 

     SELECT ENAME,
                   TRANSLATE(SAL,'0123456789' , '$Tb*D@^#%!') AS SAL
      FROM EMP ;

      jones   2975      b!#@

=>  remove all special chars from    '@#HE*^LL$%O!$' ? 


       TRANSLATE('@#HE*^LL$%O!$','@#*$^%!','*******')    => **HE**LL**O**

 SELECT 
 REPLACE(TRANSLATE('@#HE*^LL$%O!$','@#*$^%!','*******') ,'*','')
 FROM DUAL ; 


 NUMERIC functions :- 
 -------------------------------

 MOD() :- 
-------------

  => returns remainder

              MOD(num1,num2) 

 Ex :- 

           MOD(10,2)            =>    0
 
 => employees earning multiples of 100 ? 

    SELECT *
    FROM EMP
    WHERE MOD(SAL,100) = 0 ; 
 
Rounding numbers :- 
------------------------------ 

ROUND
TRUNC
CEIL
FLOOR

	 38.456789    =>  38
                                            38.45
                                            38.4567

 ROUND() :-
 ------------------

  => rounds number to integer or to decimal places  based on avg 

                    ROUND(number,[decimal places]) 

    ex :- 

       ROUND(38.4567)               =>   38

       38----------------------------38.5--------------------------------39

       number < avg     => rounded to lowest
       number >= avg  => rounded to highest 
 
       ROUND(38.5567)             =>  39 
       ROUND(38.4567,2)          =>  38.46
       ROUND(38.4537,2)          =>  38.45
       ROUND(38.4567,3)          =>  38.457

  19-DEC-23 

      => display  ENAME    EXPERIENCE in years ?

           SELECT ENAME,ROUND((SYSDATE-HIREDATE)/365) AS EXPR
           FROM EMP ; 

        ROUND(386,-2)             =>    400
      
        300---------------------------350-------------------------------400

       ROUND(386,-1)             =>     390

        380---------------------------385-----------------------------------390

       ROUND(386,-3)             =>    0

       0--------------------------------500------------------------------------1000

  Q :- 
 
   SELECT ROUND(4567,-1),ROUND(4567,-2),ROUND(4567,-3) FROM DUAL ;

     O/P :-     4570                 4600             5000

  => round salaries to hundreds in table ? 

      UPDATE EMP SET SAL = ROUND(SAL,-2) ; 

TRUNC :- 
-------------

 => rounds number always to lowest 

            TRUNC(number,[deciaml places]) 

 ex :- 

          TRUNC(38.7895)          =>     38
          TRUNC(38.7895,2)       =>     38.78
          TRUNC(386,-2)            =>      300
          TRUNC(386,-1)            =>      380
          TRUNC(999,-3)            =>      0 

 CEIL() :- 
 -------------

  => rounds number always to highest 

            CEIL(number) 

   ex :- 

            CEIL(3.1)          =>    4

FLOOR() :- 
----------------

   => rounds number always to lowest 

            FLOOR(number) 

 ex :- 

      FLOOR(3.9)                 =>  3 

DATE functions :- 
------------------------

 SYSDATE + 10              => 10 days added to sysdate 
 SYSDATE - 10              => 10 days subtracted from sysdate
 SYSDATE-HIREDATE   => calculates difference in days
 SYSDATE + HIREDATE => invalid
 
EXTRACT() :- 
------------------

 => used to extract part of the date

            EXTRACT(year/month/day  from date)

ex :- 

 EXTRACT(year from sysdate)            =>  2023
 EXTRACT(month from sysdate)         =>  12
 EXTRACT(day from sysdate)             =>  19

=> employees joined in 1980,1983,1985 ? 

    SELECT *
    FROM EMP
    WHERE EXTRACT(YEAR FROM HIREDATE) IN (1980,1983,1985) ;

=> employees joined in leap year ? 

    SELECT *
    FROM EMP
    WHERE  MOD(EXTRACT(YEAR FROM HIREDATE),4) = 0 ; 

=> employees joined in jan,apr,dec months ? 

    SELECT *
    FROM EMP
    WHERE EXTRACT(MONTH FROM HIREDATE) IN (1,4,12) ; 
 
 MONTHS_BETWEEN() :- 
 -------------------------------------

  => calculates difference between two dates in months

              MONTHS_BETWEEN(DATE1,DATE2) 

 ex :- 

  MONTHS_BETWEEN(SYSDATE,'19-DEC-22')      =>  12 

 => display  ENAME     EXPERIENCE in months ? 

     SELECT ENAME,
              FLOOR(MONTHS_BETWEEN(SYSDATE,HIREDATE)) AS EXPR
     FROM EMP ; 

 => display  ENAME       EXPERIENCE  ?
                                       M YEARS N MONTHS 

      experience = 40 months =   3 YEARS 4 MONTHS 

      years   =   months/12 =   FLOOR(40/12) = 3 
 
     months =   MOD(months,12) = MOD(40,12) = 4 

     SELECT ENAME,
         FLOOR(MONTHS_BETWEEN(SYSDATE,HIREDATE)/12) AS YEARS,
        MOD(FLOOR(MONTHS_BETWEEN(SYSDATE,HIREDATE)),12)  AS MONTHS
    FROM EMP ; 

   ADD_MONTHS() :- 
   --------------------------

  => used to add / subtract  months to/from a date

              ADD_MONTHS(DATE,MONTHS) 

   Ex :- 

  ADD_MONTHS(SYSDATE,2)            =>    19-FEB-24 
  ADD_MONTHS(SYSDATE,-2)           =>    19-OCT-23 

 => list of employees joined in last 5 years ? 

    SELECT *
    FROM EMP
    WHERE HIREDATE >=  ADD_MONTHS(SYSDATE,-60) ; 
                                        
 GOLD_RATES
 DATEID		RATE
 01-JAN-20	?
 02-JAN-20	?
 03-JAN-20	?

 19-DEC-23	? 

1  display today's gold rate ? 
2  display yesterday's gold rate ?
3  display last month same day gold rate ?
4  display last year same day gold rate ?
5 display last 1 month gold rates ? 

 SELECT *
 FROM GOLD_RATES
 WHERE  DATEID  = SYSDATE ; 

 WHERE DATEID = SYSDATE - 1 ; 

 WHERE DATEID = ADD_MONTHS(SYSDATE,-1) 

 WHERE DATEID = ADD_MONTHS(SYSDATE,-12) 

 WHERE DATEID BETWEEN ADD_MONTHS(SYSDATE,-1) AND  SYSDATE ; 

conversion functions :- 
-------------------------------

 => conversion means converting from one datatype to another datatype 
 => conversion is 2 types 

    1  implicit conversion
    2  explicit conversion 

 implicit conversion :- 
 ----------------------------

 => if conversion performed by oracle then it is called implicit conversion
 
example 1  :- 

  SQL> SELECT  5000 + '1000'   FROM DUAL  ;   => 6000

    string '1000'  converted to number by oracle

example 2 :- 
 
 SQL>CREATE TABLE T1(D   DATE) ;

 SQL>INSERT INTO T1 VALUES('01-JAN-23');

  string '01-JAN-23'  converted to date by oracle

 NOTE :- 
 -------------

  =>  implicit conversion is not recommended because it degrades performance

 20-DEC-23

 Explicit conversion :- 
 ----------------------------

  => if conversion performed by user then it is called explicit conversion
  => the following functions provided by oracle for explicit conversion 

        1  TO_CHAR
        2  TO_DATE
        3  TO_NUMBER

 converting date to char type :- 
 ---------------------------------------
 
 => Dates converted to char type to display dates in different formats.

                 TO_CHAR(DATE , 'FORMAT' )          DATE = SYSDATE

 Formats :- 
 -------------

 	yyyy			2023
	   yy			23
	year			twenty twenty three

	   mm			12
	   mon			dec 
                    month                                     december

	      ddd			354 (1-365)
                         dd                                      20
                           d     		4 (1-7)                                 
	          dy                                    wed
                           day                                  wednesday

                           hh			hour part (1-12)
	          hh24                                 hour part (1-24)
                           mi 		                  minutes
                           ss                                     seconds

                           q                                      4  (1-4)


 Examples :- 

  => display system date in mm/dd/yy format ? 

      SELECT  TO_CHAR(SYSDATE ,'MM/DD/YY') FROM DUAL ; 

  => display  ENAME     HIREDATE   ?  display hiredate in yyyy-mm-dd format ?

      SELECT ENAME,TO_CHAR(HIREDATE,'yyyy-mm-dd') AS HIREDATE 
      FROM EMP ; 
        
 => display  ENAME   DAY  ? 
 
      SELECT ENAME,TO_CHAR(HIREDATE,'DAY') AS DAY FROM EMP ; 

 => display employee list joined on sunday ?

      SELECT  *
      FROM EMP
      WHERE  TO_CHAR(HIREDATE,'DY') = 'SUN' ; 

 => display employees joined in 2nd quarter of 1981 year ?

      SELECT  *
      FROM EMP
      WHERE  TO_CHAR(HIREDATE,'YYYY') = 1981
                      AND
                     TO_CHAR(HIREDATE,'Q') = 2  ; 

     WHERE  TO_CHAR(HIREDATE,'YYYY-Q')  =  '1981-2'  ; 

 scenario :- 
 -------------- 

  INSERT INTO EMP(EMPNO,ENAME,SAL,HIREDATE)
           VALUES(999,'ABC',4000,SYSDATE); 

=> list of employees joined today ?
 
    SELECT *
    FROM EMP
    WHERE HIREDATE =  SYSDATE ;    =>  NO ROWS 

                  20-DEC-23 15:02:20  =  20-DEC-23 15:06:30

   "="  comparision with SYSDATE always fails because oracle not only
    compares date but also compares time.

  SELECT *
  FROM EMP
  WHERE  TO_CHAR(HIREDATE,'DD-MM-YYYY') = TO_CHAR(SYSDATE,'DD-MM-YYYY') ; 

  converting number to char type :- 
  --------------------------------------------

  => numbers converted to char type to display numbers in different formats 

                       TO_CHAR(number,'format') 

   formats :- 
   --------------

        9                       represents a digit
        0                       represents a digit
        G                      thousand seperator (,)
        D                      decimal seperator   (.)
        L                       currency symbol
        C                      currency 

    TO_CHAR(1234,'99999')           =>    1234
    TO_CHAR(1234,'00000')           =>    01234
    TO_CHAR(1234,'9G999')          =>    1,234
    TO_CHAR(1234,'9G999D99')    =>    1,234.00
    TO_CHAR(1234,'L9G999')        =>     $1,234
    TO_CHAR(1234,'C9G999')       =>      USD1,234 

 => display ENAME   SAL   ?  
      display salaries with thousand seperator and currency symbol ?

     SELECT ENAME,TO_CHAR(SAL,'C99G999') AS SAL FROM EMP ; 

      How to change currency  ?

   SQL>ALTER SESSION SET NLS_TERRITORY='INDIA' ; 

   SQL>ALTER SESSION SET NLS_TERRITORY='JAPAN' ;

  SQL>ALTER SESSION SET NLS_TERRITORY='AMERICA' ; 

  how to change default date format  ? 

  sql>ALTER SESSION SET NLS_DATE_FORMAT = 'MM/DD/YYYY' ;

             NLS => National Language Specification 

 21-dec-23

 converting char to date :- 
 ----------------------------------

            TO_DATE(string , 'format')

             string  =>   '21-DEC-23'
                               '12/21/23' 
                               '2023-12-21' 

  Ex :- 

  SQL>SELECT  SYSDATE + 10   FROM DUAL  ;    => 31-DEC-23

  SQL>SELECT '01-JAN-24' + 50  FROM DUAL ;    => ERROR

  number + number => valid
  date   + number  => valid
  string + number => invalid

 SQL>SELECT TO_DATE('01-JAN-24','DD-MON-YY') + 50 FROM DUAL ; 

           O/P :- 20-FEB-24

  calculate  '12/21/23' + 100  ? 

  SQL>SELECT  TO_DATE('12/21/23','MM/DD/YY') + 100 FROM DUAL ; 
 
           O/P :-  30-MAR-24

 => write a query to display on which day india got independence ?

    SQL>SELECT  
                  TO_CHAR(TO_DATE('15-AUG-1947','DD-MON-YYYY'),'DAY')
             FROM DUAL ; 

 converting char to number :- 
 --------------------------------------

        TO_NUMBER(string,'format')

        string  =>  '5000'   
                         '5,000'
                         '$5,000' 

  ex :-  

  SQL>SELECT  5000 +  '$1,000'     FROM DUAL ;   => ERROR 

  SQL>SELECT 5000 +  TO_NUMBER('$1,000','L9G999')  FROM DUAL ; 

             O/P :- 6000
 
   calculate   '$4,000' + 'USD3,000'      ? 

   SQL>SELECT  TO_NUMBER('$4,000','L9G999') + 
                            TO_NUMBER('USD3,000','C9G999')
            FROM DUAL ; 

     input		output		function

     5000                    $5,000		TO_CHAR
     $5,000                 5000                           TO_NUMBER
    DD-MON-YY        MM/DD/YY   	TO_CHAR
    MM/DD/YY          DD-MON-YY               TO_DATE               

 special functions :- 
 --------------------------

 NVL() :- 
------------

  => converts null values 

              NVL(arg1,arg2) 

         if arg1 = null  returns  arg2
         if arg1 <> null returns arg1 only 

   NVL(100,200)                 =>    100
   NVL(NULL,200)              =>    200

 => display ENAME  SAL  COMM    TOTSAL   ? 

                 TOTSAL = SAL  + COMM 

     SELECT ENAME,SAL,COMM,SAL+COMM AS TOTSAL FROM EMP ; 

 	smith	800	null	null
	allen	1600	300	1900
 
   SELECT ENAME,SAL,COMM,SAL+NVL(COMM,0) AS TOTSAL FROM EMP ; 

 	smith	800	null	800
	allen	1600	300	1900	


  => display  ENAME  SAL  COMM   ? 
        
       if comm = null display N/A 
 
     SELECT ENAME,SAL,NVL(TO_CHAR(COMM),'N/A')  AS COMM FROM EMP ;

 ASCII() :- 
 -------------

   => ascii value of a given char

         ASCII('A')     =>   65

 CHR() :- 
 -----------

   => returns char for given ascii value
 
       CHR(65)   =>  A 

How to implement a loop in sql :- 
----------------------------------------------

 SELECT LEVEL                                FOR(LEVEL=1;LEVEL<=10;LEVEL++)
 FROM DUAL                                     {
 CONNECT BY LEVEL <= 10 ;              PRINT LEVEL;
                                                           }
 
=> level is a predefined variable
=> by default level intialized with 1
=> by default level incremented by 1 

=> write a query to print even numbers upto 20 ?
 
   SELECT LEVEL
   FROM DUAL
   WHERE MOD(LEVEL,2)=0
   CONNECT BY LEVEL <= 20;   

  =>   write a query to print all ascii chars ? 

    1	?
    2	?
    3	? 

    255	?

    SELECT LEVEL , CHR(LEVEL)
    FROM DUAL
    CONNECT BY LEVEL <= 255 ; 
 
 => write a query to print 2024 calendar ? 

      01-jan-24	monday
      02-jan-24	?

      31-dec-24	? 

      SELECT   LEVEL + TO_DATE( '31-DEC-23' ,'DD-MON-YY')  AS DATEID ,
         TO_CHAR(LEVEL + TO_DATE( '31-DEC-23' ,'DD-MON-YY') ,'DAY') AS DAY
     FROM DUAL
    CONNECT BY LEVEL <= 366 ; 

   => 

   
    SELECT  LPAD('*',LEVEL,'*')
    FROM DUAL
    CONNECT BY LEVEL <= 10 ; 

	*
	**
	***

	*********

    SELECT LPAD(' ',10-LEVEL,' ')||
                  LPAD('*',LEVEL-1,'*')||
                  LPAD('*',LEVEL,'*')
  FROM DUAL
  CONNECT BY LEVEL <= 10 ; 

         *
        ***
       *****

22-dec-23

Analytical functions :- 
-----------------------------

  => these functions are useful for analysis

  RANK & DENSE_RANK :- 
  -----------------------------------

  => both functions are used to find ranks 
  => ranking is based on some column 
  => for rank functions data must be sorted 

            RANK()  OVER (ORDER BY COLNAME ASC/DESC)
            DENSE_RANK() OVER (ORDER BY COLNAME ASC/DESC)

 Ex :- 

  => find ranks of the employees based on sal and highest paid employee 
       should get 1st rank ?

       SELECT  empno,ename,sal,
                      rank() over (order by sal desc) as rnk
       FROM emp ; 

       SELECT  empno,ename,sal,
                      dense_rank() over (order by sal desc) as rnk
       FROM emp ; 

      difference between rank & dense_rank  ?

      1  rank function generates gaps but dense_rank will not generate gaps .

      2  in rank function ranks may not be in sequence but in dense_rank
         ranks are always in sequence

	SAL		RNK		DRNK
	5000		1		1		
	4000		2		2
	3000		3		3
	3000		3		3
	3000		3		3
	2000		6		4
	2000		6		4
	1000		8		5

  => find the ranks of the employees based on sal ? if salaries are same
       then ranking to be based on hiredate ?

       SELECT  empno,ename,hiredate,sal,
                      dense_rank() over (order by sal desc ,hiredate asc) as rnk
       FROM emp ; 
		
      7839 king       17-NOV-81        5000          1
      7566 jones      02-APR-81       3000          2
      7902 ford       03-DEC-81        3000          3
      7788 scott      09-DEC-82        3000         4
      7698 blake      01-MAY-81       2900          5
      7782 clark      09-JUN-81        2500         6

 => display ranks based on total desc ,m desc,p desc ? 

   STUDENT
   SNO	SNAME	M	P	C
   1	A	80	90	70
   2	B	60	50	40
   3	C	90	80	70
   4	D	90	70	80	

 GROUP functions :- 
 --------------------------

 =>  these functions process group of rows and returns one value.
 
 1 MAX
 2 MIN
 3 SUM
 4 AVG 
 5 COUNT
 6 COUNT(*)

 MAX() :- 
 ------------

  =>  returns maximum value

               MAX(colname)

   Ex :- 

   SQL>SELECT MAX(SAL) FROM EMP ;            => 5000 
   SQL>SELECT MAX(HIREDATE) FROM EMP ;  => 12-JAN-83
   SQL>SELECT MAX(ENAME) FROM EMP ;      => ward

 MIN() :- 
 -----------

 => returns minimum value 

              MIN(colname) 

   SQL>SELECT MIN(SAL) FROM EMP ;  => 800
         
 SUM() :- 
 ------------

   =>returns total 
                              SUM(colname)

   SQL>SELECT SUM(SAL) FROM EMP ;   => 29300

  => round total sal to thousands ? 

  SQL>SELECT ROUND(SUM(SAL) , -3)  FROM EMP ;   => 29000

          29000------------------29500----------------------------30000

   => after rounding display total sal with thousand seperator and currency symbol ?

     SQL>SELECT  TO_CHAR(ROUND(SUM(SAL) , -3) , 'L99G999') FROM EMP;

          O/P :- $29,000

  => calcualte total sal including comm ? 

    SQL>SELECT SUM(SAL+COMM) FROM EMP ;   => 7900

   SQL>SELECT SUM(SAL+NVL(COMM,0)) FROM EMP ;  => 31500

 AVG() :- 
 -----------

  => returns average value
 
                  AVG(colname)	 

 Ex :- 

  SQL>SELECT AVG(SAL) FROM EMP ;  => 2092.85714

  SQL>SELECT FLOOR(AVG(SAL)) FROM EMP ;  =>  2092

  NOTE :- sum,avg cannot be applied on char,date columns 

 COUNT() :- 
 ----------------

  => returns no of values present in a column 
 
             COUNT(colname)  

 SQL>SELECT COUNT(EMPNO) FROM EMP ;  => 14 

 SQL> SELECT COUNT(COMM) FROM EMP ;   => 4 => nulls are not counted

 COUNT(*) :- 
 -------------------

  => returns no of rows in a table

   SQL>SELECT COUNT(*) FROM EMP ;  => 14 

  T1
  F1
  10
  NULL
  20
  NULL
  30 

               COUNT(F1)  =   3 
               COUNT(*)    =    5

 => no of employees joined in 1981 year ? 

      SELECT COUNT(*)
      FROM EMP
      WHERE EXTRACT(YEAR FROM HIREDATE)  = 1981 ; 

 => no of employees joined on sunday ? 

      SELECT  COUNT(*)
      FROM EMP
      WHERE TO_CHAR(HIREDATE,'DY')  =  'SUN' ; 

      D
     DY
     DAY

 summary :- 
 ---------------
  
 char :- upper,lower,initcap,length,substr,lpad,rpad,ltrim,rtrim,trim,replace,translate
 numeric :-   mod,round,trunc,ceil,floor
 date      :-  extract,add_months,months_between
 conversion :- to_char,to_date,to_number
 special       :-  nvl
 analytical   :-  rank,dense_rank
 group       :-  max,min,sum,avg,count 

========================================================================

 case tatement :- 
 ----------------------- 

  => case statement is similar to switch case used to implement if-then-else
  => using case statement we can return values based on condition
  => case statements are 2 types 

      1 simple case
      2 searched case  

  simple case :- 
  --------------------

  => use simple case  when conditions based on "=" operator

   CASE  COLNAME
   WHEN VALUE1 THEN RETURN VALUE1
   WHEN VALUE2 THEN RETURN VALUE2
   WHEN VALUE3 THEN RETURN VALUE3
    ---------
   ELSE RETURN VALUE
   END

 => display ENAME	DNAME   ? 

    if deptno =10  display  ACCOUNTS
                     20               HR
                     30              IT
               others              UNKNOWN

   SELECT ENAME,
                  CASE DEPTNO
                  WHEN 10 THEN  'ACCOUNTS'
                  WHEN 20 THEN  'HR'
                  WHEN 30 THEN 'IT'
                  ELSE 'UNKNOWN'
                  END  AS DNAME
    FROM EMP ; 

 => increment employee salaries as follows ?

    if job=CLERK  incr sal by 10%
              SALESMAN           15%
               MANAGER            20%
                others                   5%

   UPDATE EMP
   SET SAL =  CASE JOB
                      WHEN 'CLERK' THEN  SAL+(SAL*0.1)
                      WHEN 'SALESMAN' THEN SAL+(SAL*0.15)
                      WHEN 'MANAGER' THEN SAL+(SAL*0.2)
                      ELSE SAL+(SAL*0.05)
                      END  ; 

23-dec-23 

 searched case :- 
 ----------------------

  => use searched case when conditions not based on "=" operator

   CASE
   WHEN COND1 THEN RETURN VALUE1
   WHEN COND2 THEN RETURN VALUE2
   WHEN COND3 THEN RETURN VALUE3
   ELSE  RETURN VALUE
   END

 => Display  ENAME      SAL         SALRANGE     ? 

                                                      0-2000
                                                      2001-4000
                                                      above 4000

          SELECT  ENAME,SAL,
                          CASE 
                          WHEN SAL  BETWEEN 0 AND 2000 THEN '0-2000'
                          WHEN SAL BETWEEN 2001 AND 4000 THEN '2001-4000'            
                          WHEN SAL>4000 THEN  'ABOVE 4000'
                          END  AS SALRANGE
          FROM EMP ; 

 => display  SNO    TOTAL   AVG  RESULT   ? 

    STUDENT
    SNO	SNAME	S1	S2	S3 
   1	A	80	90	70
   2	B	30	60	50

  SELECT SNO,
                 S1+S2+S3 AS TOTAL,
                 (S1+S2+S3)/3 AS AVG,
                 CASE
                  WHEN S1>=35  AND S2>=35 AND S3>=35  THEN  'PASS'
                  ELSE 'FAIL'
                  END AS RESULT
  FROM STUDENT ; 
 
 SNO	TOTAL	AVG	RESULT
  1	240	80	PASS
  2	140	46.	FAILE
         
============================================================================

 GROUP BY clause :- 
 ----------------------------

 => GROUP BY clause groups rows based on one or more columns to calculate
      min,max,sum,avg,count for each group. For example to calculate dept wise
      total sal  first group the records based on deptno and apply sum function
      on each dept.

     EMP
    EMPNO   ENAME  SAL  DEPTNO 
     1	     A	 3000 10
     2	    B	 5000 20		group by		10	7000
     3	    C	 4000 30  =====================>	20	8000
     4	    D	 3000 20				30	4000
     5	    E	 4000 10

     detailed data					summarized data 

    => GROUP BY clause converts detailed data into summarized data which is useful for analysis
				
					EXECUTION :- 

   SELECT COLUMNS			FROM			
   FROM TABNAME				WHERE
   [WHERE COND]				GROUP BY
   GROUP BY COL1,COL2,---			HAVING
   [HAVING COND]				SELECT
   [ORDER BY COL1,COL2,----]   ;		ORDER BY 

Examples :- 

  =>  display  dept wise total salary  ? 

     SELECT DEPTNO,SUM(SAL)
     FROM EMP
     GROUP BY DEPTNO
     ORDER BY DEPTNO ASC ;
 
   FROM EMP :- 
  --------------------
 
    EMPNO   ENAME  SAL  DEPTNO 
     1	     A	 3000 10
     2	    B	 5000 20		 
     3	    C	 4000 30   
     4	    D	 3000 20				 
     5	    E	 4000 10

 GROUP BY DEPTNO :- 
 ----------------------------------
 
  10	1	A	3000
	5	E	4000

  20	2	B	5000
	4	D	3000

  30	3	C	4000

 SELECT DEPTNO,SUM(SAL) :- 
 -------------------------------------------

  10	7000
  20	8000
  30	4000
 
=> display job wise summary  ? 

   SELECT JOB, MIN(SAL) AS MINSAL,
                          MAX(SAL) AS MAXSAL,
                          SUM(SAL) AS TOTSAL,
                          COUNT(*) AS CNT
   FROM EMP
   GROUP BY JOB ; 

 => display year wise no of employees joined ? 

     SELECT   EXTRACT(YEAR FROM HIREDATE) AS YEAR,  COUNT(*)
     FROM EMP
     GROUP BY  EXTRACT(YEAR FROM HIREDATE) ;

	 YEAR     COUNT(*)
	---------- 	----------
    	 1980           1
     	 1983            1
      	 1982            2
      	 1981           10

  => month wise no of employees joined in the year 1981 ? 
 
    SELECT  TO_CHAR(HIREDATE,'MONTH') AS MONTH,COUNT(*)
    FROM EMP
    WHERE EXTRACT(YEAR FROM HIREDATE)=1981
    GROUP BY TO_CHAR(HIREDATE,'MONTH') ; 

   => find departments having more than 3 employees ? 

        SELECT DEPTNO,COUNT(*)
        FROM EMP
       WHERE COUNT(*) > 3 
       GROUP BY DEPTNO  ;       =>  ERROR 

   => oracle cannot calculate dept wise count before group by and it can calculate
        only after group by , so apply the condition COUNT(*) > 3  after group by
        using having clause.

        SELECT DEPTNO,COUNT(*)
        FROM EMP
        GROUP BY DEPTNO  
        HAVING COUNT(*) > 3 ;

	20	5
	30	6

 WHERE VS HAVING :-
 -------------------------------

	WHERE			HAVING

1	selects specific rows		selects specific groups 

 2	conditions applied		conditions applied 
                 before group by		after group by 

 3	use where clause		use having clause
                 if cond doesn't		if cond contains 
                 contain group function	group function

26-DEC-23 

 => find southern states having more than 5cr population ? 

   PERSONS
   AADHARNO    NAME    GENDER     AGE      ADDR     CITY     STATE 
 
  SELECT COUNT(*)
  FROM PERSONS 
  WHERE STATE  IN ('AP','TS','TN','KA','KL')
  GROUP BY STATE 
  HAVING COUNT(*) > 50000000 ;
 
=> display dept wise and with in dept job wise total sal ?

   SQL>BREAK ON DEPTNO SKIP 1 

   SQL>SELECT  DEPTNO,JOB,SUM(SAL) 
     FROM EMP 
     GROUP BY DEPTNO,JOB  
     ORDER BY DEPTNO ASC ; 


 10	CLERK		1300
	MANAGER	2500
	PRESIDENT	5000

  20	ANALYST		6000
	CLERK		1900
	MANAGER	3000
 
  30	CLERK		1000
	MANAGER	2900
	SALESMAN	5700

 => display year wise and with in year quarter wise no of employees joined ?

     SELECT  TO_CHAR(HIREDATE,'YYYY') AS YEAR,
                     TO_CHAR(HIREDATE,'Q') AS QRT,
                      COUNT(*) AS CNT
     FROM EMP
     GROUP BY YEAR , QRT     /*   INVALID  */
     ORDER BY YEAR  ASC    /* VALID */   ;

   NOTE :- 

   => alias cannot be used in  group by clause because group by clause is executed before select 
   => alias can be used in order by clause because order by clause is executed after select

     SELECT   TO_CHAR(HIREDATE,'YYYY') AS YEAR,
                      TO_CHAR(HIREDATE,'Q') AS QRT,
                      COUNT(*) AS CNT
     FROM EMP
     GROUP BY  TO_CHAR(HIREDATE,'YYYY'),TO_CHAR(HIREDATE,'Q')
     ORDER BY YEAR  ASC   ; 
 
 ROLLUP & CUBE :- 
 ----------------------------

 => both functions are used to display subtotals and grand total
 
                  GROUP BY ROLLUP(COL1,COL2,---)
                  GROUP BY  CUBE(COL1,COL2,------)

 ROLLUP :- 
 ----------------

 => ROLLUP displays subtotals for each group and also displays grand total.

     SELECT  DEPTNO,JOB,SUM(SAL) 
     FROM EMP 
     GROUP BY ROLLUP(DEPTNO,JOB)
     ORDER BY DEPTNO ASC ; 

 10	CLERK		1300
	MANAGER	2500
	PRESIDENT	5000
			8800  => subtotal

  20	ANALYST		6000
	CLERK		1900
	MANAGER	3000
			10900  => subtotal
 
  30	CLERK		1000
	MANAGER	2900
	SALESMAN	5700
			9600  => subtotal
	
			29300 => grand total

CUBE :- 
------------

 => cube displays subtotals for each group by column (deptno,job) 

     SELECT  DEPTNO,JOB,SUM(SAL) 
     FROM EMP 
     GROUP BY CUBE(DEPTNO,JOB)
     ORDER BY DEPTNO ASC ; 

 10	CLERK		1300
	MANAGER	2500
	PRESIDENT	5000
			8800  => dept subtotal

  20	ANALYST		6000
	CLERK		1900
	MANAGER	3000
			10900  => dept  subtotal
 
  30	CLERK		1000
	MANAGER	2900
	SALESMAN	5700
			9600  => dept subtotal
       
 	ANALYST		600     => job subtotal
	CLERK		4200   => job subtotal
	MANAGER	8400
	PRESIDENT	5000
	SALESMAN	5700

			29300  => grand total

Assignment :- 
---------------------

=> display state wise and with in state gender wise population and display state wise 
     and gender wise subtotals ?

   PERSONS
   AADHARNO    NAME    GENDER     AGE      ADDR     CITY     STATE 

 => display year wise and with in year quarter wise total amount ? display year wise subtotals ?

    SALES
    DATEID    PRODID   CUSTID    QTY   AMT   


summary :- 

 => importance of group by
 => writing queries using group by 
 =>  where vs having
 => rollup & cube

=========================================================================

			Integrity Constraints
			--------------------------
 
 => Integrity constraints are rules to maintain Data Integrity i.e. Data Quality or Data Consistency.
 => used to prevent users from entering invaid data.
 => used to enforce rules like min bal must be 1000

 Types of constraints :- 
 -----------------------------

 1 NOT NULL
 2 UNIQUE
 3 PRIMARY KEY
 4 CHECK
 5 FOREIGN KEY 
 
=> above constraints can be declared in two ways 
 
 1  column level
 2  table level

column level :- 
---------------------

 => if constraints are declared immediately  after declaring column then it is 
      called column level.

  CREATE TABLE <TABNAME>
  (
   COLNAME DATATYPE(SIZE)  CONSTRAINT ,
  -----------------------------------
 );

NOT NULL :- 
------------------

 => NOT NULL constraint doesn't  accept null values 
 => a field declared with NOT NULL is called mandatory field

ex :- 

 CREATE TABLE EMP11
 (
  EMPNO  NUMBER(4),
  ENAME  VARCHAR2(10)  NOT NULL
 );

 INSERT INTO EMP11 VALUES(100,'');   => ERROR
 INSERT INTO EMP11 VALUES(101,'A'); 

UNIQUE :- 
---------------

  => unique constraint doesn't accept duplicates 
 
 ex :- 

 CREATE TABLE CUST
 (
   CID  NUMBER(4),
   NAME VARCHAR2(10) NOT NULL,
   EMAILID  VARCHAR2(20) UNIQUE
 );

 INSERT INTO CUST VALUES(100,'A','abc@gmail.com');
 INSERT INTO CUST VALUES(101,'B','abc@gmail.com'); => ERROR
 INSERT INTO CUST VALUES(102,'C','');
 INSERT INTO CUST VALUES(103,'D','');

NOTE :- unique constraint doesn't allow duplicates but allows nulls 

27-DEC-23 

PRIMARY KEY :- 
-----------------------

 => primary key doesn't accept duplicates & nulls.

 => primary key is the combination of unique & not null.

          primary key  = unique + not null 

 => In tables one column must be there to uniquely identify the records
      and into that column duplicates and nulls are not allowed so declare
      that column with primary key.

 ex :- 

   CREATE TABLE EMP12
   (
        EMPNO   NUMBER(4)  PRIMARY KEY,
        ENAME   VARCHAR2(10)   NOT  NULL
   );

 INSERT INTO EMP12  VALUES(100,'A');
 INSERT INTO EMP12  VALUES(100,'B');        => ERROR
 INSERT INTO EMP12  VALUES(NULL,'C');     => ERROR

NOTE :- 

  => a table allows only one primary key  , if we want multiple primary keys then
       declare one column with primary key and other columns with unique not null.

   CREATE TABLE CUST
   (
     CUSTID    NUMBER(6)  PRIMARY KEY,
     NAME       VARCHAR2(10) NOT NULL,
     AADHARNO   NUMBER(12)  UNIQUE NOT NULL,
     PANNO          CHAR(10)    UNIQUE NOT NULL
 );

difference between unique & primary key  ?

  	unique			primary key

1   allows null values			doesn't allow null values

2  multiple columns can		only one column can be		
    be declared with			declared with primary key
    unique

 candidate key :- 
 ---------------------

 =>  a field eligible for primary key is called candidate key

 ex :- 
            VEHICLE
            VEHNO     NAME       MODEL       COST           CHASSISNO
 
            candidate keys :-  VEHNO,CHASSISNO
            primary key      :-  VEHNO
            secondary key  :-  CHASSISNO 
            or
            alternate key

 => while creating table secondary keys are declared with UNIQUE NOT NULL.

 CHECK :- 
 -------------

 => use check constraint when rule based on condition.

                   CHECK(condition)

 ex 1 :-   sal must be min 3000

   CREATE TABLE EMP13
   (
     EMPNO  NUMBER(4)  PRIMARY KEY,
     ENAME   VARCHAR2(10) NOT NULL, 
     SAL         NUMBER(7)  CHECK(SAL>=3000)
  );

 INSERT INTO EMP13 VALUES(100,'A',1000);  => ERROR
 INSERT INTO EMP13 VALUES(101,'B',5000);
 INSERT INTO EMP13 VALUES(102,'C',NULL);

NOTE :- check constraint allows nulls

2   gender  must be 'm','f'   ?

     GENDER  CHAR(1)  CHECK(GENDER IN ('M','F'))

 3  amt must be multiple of 100 ?

     AMT     NUMBER(5)  CHECK(MOD(AMT,100)=0)

 4  pwd must be min 6 chars ?
 
     PWD   VARCHAR2(10)  CHECK( LENGTH(PWD) >= 6)

5   emailid must contain '@'
                 must end with  '.com'  or  '.co'  or    '.in' 

     emailid   varchar2(20)  CHECK(emailid like  '%@%'
                                                      and
                                                      (
                                                       emailid like '%.com'
                                                       or
                                                      emailid like '%.co'
                                                      or
                                                      emailid like '%.in'
                                                      ))

FOREIGN KEY :- 
-------------------------

 => foreign key is used to establish relationship between two tables 

 => To establish relationship take primary key of one table and
      add it to another table as foreign key and declare with 
      references constratint.

ex :-

 DEPT
 DNO	DNAME	LOC
10	HR	HYD
20	IT	BLR
 

EMP
EMPNO	ENAME	SAL	DNO    REFERENCES DEPT(DNO)
1	A	5000         10
2	B	4000         20
3	C	3000         90  => ERROR
4	D	4000	10
5	E	3000	NULL

 => values entered in foreign key column should match with values entered
      in primary key column.

 => foreign key allows duplicates & nulls.

 => after declaring foreign key a relationship is created between two tables
      called parent / child relationship.

 => primary key table is parent and foreign key table is child.
 
 CREATE TABLE DEPT55
 (
  DNO  NUMBER(2)   PRIMARY KEY,
  DNAME  VARCHAR2(10) UNIQUE NOT NULL,
  LOC     VARCHAR2(10) 
 );

INSERT INTO DEPT55 VALUES(10,'HR','HYD');
INSERT INTO DEPT55 VALUES(20,'IT','BLR');

CREATE TABLE EMP55
(
  EMPNO  NUMBER(4)  PRIMARY KEY,
  ENAME   VARCHAR2(10)  NOT NULL,
  SAL         NUMBER(7)  CHECK(SAL BETWEEN 5000 AND 10000) ,
  DNO       NUMBER(2)   REFERENCES DEPT55(DNO)
 );

INSERT INTO EMP55 VALUES(1,'A',6000,10);
INSERT INTO EMP55 VALUES(2,'B',5000,90); => ERROR
INSERT INTO EMP55 VALUES(3,'C',5000,10);
INSERT INTO EMP55 VALUES(4,'F',5000,NULL);
			 
Assignment :- 

 ACCOUNTS
 ACCNO	ACTYPE	BAL 

 Rules :- 
-----------

 1  accno should not be duplicate & null
 2  actype must be 'S' OR 'C' 
 3  bal must be min 1000

TRANSACTIONS
TRID	TTYPE	TDATE	TAMT	ACCNO

Rules :- 

 1  trid should not be duplicate & null
 2  ttype must be 'w' or 'd'
 3  tamt must be multiple of 100
 4  accno should match with accounts table accno 
 5  accno should not be null

CREATE TABLE ACCOUNTS
(
   ACCNO  NUMBER(4)  PRIMARY KEY,
   ACTYPE CHAR(1)   CHECK(ACTYPE IN ('S','C')) ,
   BAL        NUMBER(8) CHECK(BAL >= 1000)
 );

CREATE TABLE TRANSACTIONS
(
  TRID     NUMBER(10)  PRIMARY KEY,
  TTYPE  CHAR(1)   CHECK(TTYPE IN ('W','D')),
  TDATE  DATE ,
  TAMT    NUMBER(6)  CHECK(MOD(TAMT,100)=0),
  ACCNO  NUMBER(4)  REFERENCES ACCOUNTS(ACCNO)  NOT NULL
 );


28-DEC-23 

 Relationship Types :-
 ----------------------------

1  one to one (1:1)
 2 one to many (1:m)
 3 many to one (m:1)
 4 many to many (m:n)

=> by default oracle creates one to many relationship between two tables 

 how to establish one to one relationship  :- 
 -------------------------------------------------------
 
 => to establish one to one relationship declare foreign key with unique constraint.

 ex :- 

 DEPT
 DNO	DNAME
 10	HR
 20	IT

MGR
MGRNO	MNAME	  DNO    REFERENCES DEPT(DNO)   UNIQUE
 1	A                10
 2	B                20
 
 => above example one dept is managed by one manager and one manager
     manages exactly one dept , so relationship between dept & mgr is 
     one to one. so declare foreign key with unique constraint.

many to many relationship :- 
--------------------------------------

=> if relationship is many to many then create third table and in third table
     take primary keys of both tables as foreign keys.

ex :-

STUDENT			COURSE	
SID	SNAME		CID	CNAME
1	A		10	JAVA
2	B		11	ORACLE

REGISTRATIONS
SID	CID	DOR	FEE
1	10	?	?
1	11	?	?
2	10	?	?	




Relational model for the above er model :-
--------------------------------------------------------

BANK
CODE	NAME	ADDR
---------

BRANCH
BRANCH_ID	NAME	ADDR           CODE(FK)
-----------------

ACCOUNTS
ACCNO	ACTYPE	BAL      BRANCH_ID(FK)    CUSTID(FK)
-----------

LOANS
LOAN_ID	LOAN_TYPE	AMT	BANCH_ID(FK)        CUSTID(FK)
------------

CUSTOMER
CUSTID	NAME	PHONE	ADDR
-----------

TABLE LEVEL :-
-----------------------

 => table level constraints are declared after declaring all columns 
 => use table level to declare constraints for multiple or combination of columns

 Declaring check constraint at table level :- 
 ---------------------------------------------------------

 products
 prodid	pname	mfd_dt		exp_dt
 100	A	01-DEC-23	01-JAN-23     INVALID

            Rule :-  exp_dt >   mfd_dt 

 create table products
 (
  prodid number(3) primary key,
  pname varchar2(10) not null,
  mfd_dt  date   ,
  exp_dt date ,
             check(exp_dt > mfd_dt)
 );

 INSERT INTO products VALUES(100,'A',SYSDATE,'01-JAN-23');  => ERROR
 INSERT INTO products VALUES(101,'B', '01-JAN-23',SYSDATE);

 composite primary key :- 
 ---------------------------------

 => if combination of columns declared primary key then it is called composite
      primary key.

 => In some tables we may not be able to uniquely identify records by using
      single column and we need combination of columns to uniquely 
      identity and that combination should be declared primary key at table level.

   ex :- 

student			course
sid	sname		cid	cname
1	A		10	JAVA
2	B		11	ORACLE

registrations
sid	cid	dor	fee
-------------------
1	10	?	?
1	11	?	?
2	10	?	?

create table student
(
 sid  number(2) primary key,
 sname varchar2(10) not null
);
 
insert into student values(1,'A');
insert into student values(2,'B');

create table course
(
 cid  number(2) primary key,
 cname varchar2(10) not null
);

insert into course values(10,'java');
insert into course values(11,'oracle');

create table registrations
(
  sid  number(2)   references student(sid),
  cid  number(2)   references course(cid),
  dor  date,
  fee  number(5),
                 primary key(sid,cid)
 );

insert into registrations values(1,10,sysdate,1000);
insert into registrations values(1,11,sysdate,1000);
insert into registrations values(2,10,sysdate,1000);
insert into registrations values(1,10,sysdate,1000);  => ERROR

 29-dec-23 

 composite foreign key :- 
 ---------------------------------

  => if foreign key declared for combination then it is called composite foreign key

registrations
sid	cid	dor	fee
-------------------
1	10	?	?
1	11	?	?
2	10	?	?

certificates
certno	doi	sid	cid
1000	??	1	10
1001	?	1	11
1002	?	2	11

=> in the above example sid,cid combination should match with registration
     table sid,cid combination , so declare this combination as foreign key
     at table level.

   CREATE TABLE CERTIFICATES
   (
       CERTNO  NUMBER(4)  PRIMARY KEY,
       DOI          DATE,
       SID          NUMBER(2)  ,
       CID          NUMBER(2) ,
             FOREIGN KEY (SID,CID)   REFERENCES REGISTRATIONS(SID,CID)
   );

 which of the following constraint cannot be declared at table level ? 

 A   UNIQUE
 B  CHECK
 C  NOT NULL
 D  PRIMARY KEY
 E  FOREIGN KEY 

  ANS :-   C 

   Which statements are true regarding constraints ?

A  a foreign key cannot contain NULL value    F
B  a column with UNIQUE constraint can contain NULL value   T
C  a constraint is enforced only for the INSERT operation on a table   F
D all constraints can be defined at column level and table level.  F

Which CREATE TABLE statement is valid?

A. CREATE TABLE ord_details
(ord_no NUMBER(2) PRIMARY KEY,
item_no NUMBER(3) PRIMARY KEY,
ord_date DATE NOT NULL);

B. CREATE TABLE ord_details
(ord_no NUMBER(2) UNIQUE, NOT NULL,
item_no NUMBER(3),
ord_date DATE DEFAULT SYSDATE NOT NULL);

C. CREATE TABLE ord_details
(ord_no NUMBER(2) ,
item_no NUMBER(3),
ord_date DATE DEFAULT NOT NULL,
  UNIQUE (ord_no),
  PRIMARY KEY (ord_no));

D. CREATE TABLE ord_details
(ord_no NUMBER(2),
item_no NUMBER(3),
ord_date DATE DEFAULT SYSDATE NOT NULL,
  PRIMARY KEY (ord_no, item_no));

Adding constraints to existing table :- 
--------------------------------------------------

 => "ALTER"  command is used to add constraints to existing table.

 ex :- 

   CREATE TABLE EMP77
   (
      EMPNO  NUMBER(4) ,
      ENAME  VARCHAR2(10) ,
      SAL         NUMBER(7),
      DNO        NUMBER(2)
    );

Adding primary key :- 
-----------------------------

=>   add primary key to empno ?

      ALTER TABLE EMP77
           ADD PRIMARY KEY (EMPNO) ; 

Adding check constraint :- 
-----------------------------------

 =>  add check constraint with cond sal>=3000  ?

  ALTER TABLE EMP77
           ADD  CHECK(SAL>=3000);

   ALTER TABLE EMP 
           ADD  CHECK(SAL>=3000);  => ERROR

  => above command returns error because some of the employee salaries
       are less than 3000, so while adding constraint oracle also validates 
       existing data.

 NO VALIDATE :- 
 -----------------------

 => if check constraint is added with " NO VALIDATE "  then oracle doesn't
      validate existing data and it validates only new data.

    ALTER TABLE EMP 
           ADD  CHECK(SAL>=3000) NOVALIDATE ; 

Adding foreign key :-
---------------------------

=> add fk to dno  that should match with dept55 table primary key i.e. dno  ?

    ALTER TABLE  EMP77
           ADD FOREIGN KEY(DNO)  REFERENCES DEPT55(DNO) ; 

 Changing from NULL to NOT NULL :- 
 --------------------------------------------------

   => modify the column ename to not null ? 

     ALTER TABLE EMP77
           MODIFY (ENAME  NOT NULL) ; 

  
 USERS                  ALL_USERS
 TABLES                USER_TABLES
 COLUMNS            USER_TAB_COLUMNS
 CONSTRAINTS     USER_CONSTRAINTS 

 USER_CONSTRAINTS :- 
 ---------------------------------

  => stores information about constraints declared in a table.

   SELECT CONSTRAINT_NAME,CONSTRAINT_TYPE,
                  SEARCH_CONDITION
   FROM USER_CONSTRAINTS 
   WHERE TABLE_NAME='EMP77' ; 

CONSTRAINT_NAME      	C 	SEARCH_CONDITION
-------------------- 		 - 	------------------------------
SYS_C008846          		 C 	SAL>=3000
SYS_C008848         		 R
SYS_C008849         		 C 	"ENAME" IS NOT NULL
SYS_C008845          		 P

Droping constraints :- 
-------------------------------

  ALTER TABLE <TABNAME>
      DROP CONSTRAINT <NAME> ;

 => drop check constraint in emp77 table ? 

     ALTER TABLE EMP77
           DROP CONSTRAINT   SYS_C008846  ; 

=> drop primary key in emp77 table ?

   ALTER TABLE EMP77
         DROP  PRIMARY KEY ; 

=> drop primary key in dept55 table ?

    ALTER TABLE DEPT55
             DROP  PRIMARY KEY ;    => ERROR

    ALTER TABLE DEPT55             => ERROR
                    DROP (DNO);

   DROP TABLE DEPT55;   => ERROR

  primary key cannot be dropped if referenced by some fk
  primary key column cannot be dropped if referenced by some fk
  primary key table cannot be dropped if referenced by some fk
 
  ALTER TABLE DEPT55
             DROP  PRIMARY KEY  CASCADE ;  =>  drop pk along with fk 

 DROP TABLE DEPT55  CASCADE CONSTRAINTS ; => drops table with 
                                                                                          dependent foreign keys
30-DEC-23

DELETE RULES :-
--------------------------

 1 ON DELETE NO ACTION (DEFAULT)
 2 ON DELETE CASCADE
 3 ON DELETE SET NULL 

 => delete rules are declared with foreign key.
 => a delete rule defines how child rows are affected if parent row is deleted

ON DELETE NO ACTION :- 
-------------------------------------

=>  parent row cannot be deleted if associated with child rows 

  CREATE TABLE DEPT99
  (
        DNO   NUMBER(2)  PRIMARY KEY,
        DNAME  VARCHAR2(10) NOT NULL
 );

 INSERT INTO DEPT99 VALUES(10,'HR');
 INSERT INTO DEPT99 VALUES(20,'IT');

 CREATE TABLE EMP99
 (
   EMPNO  NUMBER(4) PRIMARY KEY,
   ENAME   VARCHAR(10) NOT NULL,
   DNO        NUMBER(2) REFERENCES DEPT99(DNO)
 );

  INSERT INTO EMP99 VALUES(1,'A',10);
 
  DELETE FROM DEPT99 WHERE DNO=10;   => ERROR

 scenario :- 
----------------

 ACCOUNTS
 ACCNO	  BAL
 100	10000 
 101	20000

 LOANS
 LOANID	TYPE	AMT	ACCNO
 1	H	30	100
 2	C	10	100

  NOTE :- account closing is not possible if associated with loans 

 ON DELETE CASCADE :- 
 -----------------------------------

 => parent record is deleted along with child records .

   CREATE TABLE DEPT99
  (
        DNO   NUMBER(2)  PRIMARY KEY,
        DNAME  VARCHAR2(10) NOT NULL
 );

 INSERT INTO DEPT99 VALUES(10,'HR');
 INSERT INTO DEPT99 VALUES(20,'IT');

 CREATE TABLE EMP99
 (
   EMPNO  NUMBER(4) PRIMARY KEY,
   ENAME   VARCHAR(10) NOT NULL,
   DNO        NUMBER(2) REFERENCES DEPT99(DNO) 
                                        ON DELETE CASCADE 
 );

  INSERT INTO EMP99 VALUES(1,'A',10);

  DELETE FROM DEPT99 WHERE DNO=10;  => 1 ROW DELETED 

  SELECT * FROM EMP99 ;   => NO ROWS 

 SCENARIO :- 
------------------

ACCOUNTS
ACCNO	 BAL
100	10000
101	20000

TRANSACTIONS
TRID	TTYPE	TDATE	TAMT	ACCNO       REFERENCES ACCOUNTS(ACCNO)
1	W	?	2000	100              ON DELETE CASCADE
2	D	?	5000	100

NOTE :-  if account is closed along with the account delete transactions 

ON DELETE SET NULL :- 
-----------------------------------

=> parent row is deleted without deleting child rows but fk will be set to NULL.

    CREATE TABLE DEPT99
  (
        DNO   NUMBER(2)  PRIMARY KEY,
        DNAME  VARCHAR2(10) NOT NULL
 );

 INSERT INTO DEPT99 VALUES(10,'HR');
 INSERT INTO DEPT99 VALUES(20,'IT');

 CREATE TABLE EMP99
 (
   EMPNO  NUMBER(4) PRIMARY KEY,
   ENAME   VARCHAR(10) NOT NULL,
   DNO        NUMBER(2) REFERENCES DEPT99(DNO) 
                                        ON DELETE SET NULL
 );

  INSERT INTO EMP99 VALUES(1,'A',10);
 
  DELETE FROM DEPT99 WHERE DNO = 10;   => 1 ROW DELETED

  SELECT * FROM EMP99 ;

  1	A	NULL

 scenario :-
---------------

 PROJECTS
 projid	name	duration	cost	client
 100	A	5 YEARS  800	TATA MOTORS
 101
 
 EMP
 empid	ename	sal	projid    REFERENCES PROJECTS (projid)
 1			100       ON DELETE SET NULL
 2			101

Rule :- if project is completed (deleted)  then set employee projid to null 


summary :- 

 importance of constraints
 types of constraints
 declaring constraints
       column level
       table level
 relationship types
 adding constraints to existing table
 droping constraints
 getting constraints information
 delete rules 

=========================================================================

			  JOINS
			  ----------

  => join is an operation performed to display data from two or more tables.

  => in db related data stored in multiple tables , to gather or to combine
       data stored in multiple tables we need to join those tables.

 ex :- 

   ORDERS					CUST
   ORDID    ORDDT   DELDT    CID			CID	NAME	ADDR
  1000	   ?	 ?	10			10	A	HYD
  1001			11			11	B	HYD
  1002			12			12	C	HYD

  output :- 
 
   ORDID	ORDDT	DELDT	NAME	ADDR
  1000			A	HYD 
  1001			B	HYD

 Types of joins :- 
 ---------------------

 1  Equi join / Inner join
 2  Outer join
           left outer
           right outer
           full outer
 3  Non equi join
 4  Self join
 5  Cross join / Cartesian join  

 Equi Join / Inner join :- 
 ------------------------------

  => To perform equi join between the tables there must be a common field and
       name of the common field need not to be same and pk-fk relationship is not compulsory.

       SELECT  COLUMNS
       FROM TAB1 INNER JOIN TAB2 
            ON  JOIN CONDITION ; 

 join condition :- 
 --------------------

 => oracle joins the records of two tables based on given join condition.

 => join cond determines which record of 1st table should be joined with which record of 2nd table

               table1.commonfield  =  table2.commonfield 

 Ex :- 

    EMP					DEPT
    EMPNO    ENAME   SAL   DEPTNO		DEPTNO	DNAME		LOC
    1                A             3000 10			10	ACCOUNTS	NEW YORK	
    2                B             4000 20			20	RESEARCH
    3               C             5000  30			30	SALES
    4               D             3000  20			40	OPERATIONS
    5	    E	   2000  NULL

 => display   ENAME	  SAL      DNAME        LOC   ? 
                    ------------------       ----------------------
                          EMP                     DEPT

   SELECT  ENAME,SAL,DNAME,LOC
     FROM   EMP INNER JOIN DEPT
          ON   EMP.DEPTNO = DEPT.DEPTNO ;

	A	3000	ACCOUNTS	NEW YORK
  	B	4000	RESEARCH	?
	C	5000	SALES		?
   	D	3000	RESEARCH	?

 NOTE :-   in join queries declare table alias and prefix column names with table alias 
                 for two reasons 

             1    to avoid ambiguity
             2    for faster execution

   SELECT  E.ENAME,E.SAL,
                   D.DEPTNO,D.DNAME,D.LOC
     FROM   EMP  E INNER JOIN DEPT D
          ON   E.DEPTNO = D.DEPTNO ;

 => display employee details with dept details working at NEW YORK loc ? 

     SELECT  E.ENAME,D.DNAME,D.LOC
         FROM EMP E  INNER JOIN DEPT D
              ON E.DEPTNO = D.DEPTNO    /*   join cond */
      WHERE D.LOC = 'NEW YORK'   /*  filter  cond */   ; 

01-JAN-24 

  joining more than 2 tables :- 
  -------------------------------------

 => if no  of tables increases no of join conditions also increases 
 => to join N tables N-1 join conditions required
 
 SELECT 	columns
 FROM tab1 INNER JOIN tab2
      ON join cond
                    INNER JOIN tab3
      ON join cond
                   INNER JOIN tab4
      ON join cond
 [WHERE cond] ; 

 ex :- 

  EMP                DEPT              LOCATIONS        COUNTRIES
  empno             deptno             locid                    country_id
  ename             dname             city	          country_name
  sal                    locid                state
  deptno                                     country_id

 => Display  ENAME	DNAME	CITY	STATE	COUNTRY   ?
                   -----------  -----------   ------------------------     ----------------
                      EMP     DEPT       LOCATIONS             COUNTRIES

      SELECT E.ENAME,
                    D.DNAME,
                    L.CITY,L.STATE,
                    C.COUNTRY_NAME
      FROM    EMP E  INNER JOIN DEPT D
           ON    E.DEPTNO = D.DEPTNO 
                                 INNER JOIN LOCATIONS L
            ON   D.LOCID = L.LOCID
                                 INNER JOIN COUNTRIES C
            ON   L.COUNTRY_ID = C.COUNTRY_ID ; 
 
 OUTER JOIN :- 
 ----------------------

  => inner join returns only matching records but can't return unmatched records ,
       to display unmatched records perform outer join.

  ex :- 

    EMP					DEPT
    EMPNO    ENAME   SAL   DEPTNO		DEPTNO	DNAME		LOC
    1                A             3000 10			10	ACCOUNTS	NEW YORK	
    2                B             4000 20		20	RESEARCH
    3               C             5000  30		30	SALES
    4               D             3000  20		40	OPERATIONS   => unmatched
    5	    E	   2000  NULL  => unmatched

=> outer join is 3 types 

   1 left outer join
   2 right outer join
   3 full outer join 

 left outer join :- 
 ----------------------

 => returns all rows (matched + unmatched)  from left side table and matching
      rows from right side table.

     SELECT E.ENAME,D.DNAME
        FROM EMP E   LEFT OUTER JOIN DEPT D
             ON E.DEPTNO = D.DEPTNO ; 

   => returns all rows from emp table and matching rows from dept table

      A	ACCOUNTS 
      B	RESEARCH
      C	SALES
      D	RESEARCH
      E	NULL    => unmatched from emp 

  right outer join :- 
  ------------------------

   => returns all rows from right side table and matching rows from left side table.

   SELECT E.ENAME,D.DNAME
        FROM EMP E RIGHT OUTER  JOIN DEPT D
             ON E.DEPTNO = D.DEPTNO ; 

	A	ACCOUNTS
	B	RESEARCH	
	C	SALES
	D	RESEARCH
	NULL	OPERATIONS   =>  unmatched from dept

 FULL OUTER JOIN :- 
 ------------------------------

  => returns all rows from both tables 

 SELECT E.ENAME,D.DNAME
        FROM EMP E FULL OUTER  JOIN DEPT D
             ON E.DEPTNO = D.DEPTNO ; 

	A	ACCOUNTS
	B	RESEARCH	
	C	SALES
	D	RESEARCH
	E	NULL		=> unmatched from emp
	NULL	OPERATIONS   	=> unmatched from dept

Displaying only unmatched records :- 
--------------------------------------------------

 left side :- 
----------------

    SELECT E.ENAME,D.DNAME
        FROM EMP E   LEFT OUTER JOIN DEPT D
             ON E.DEPTNO = D.DEPTNO 
       WHERE D.DNAME IS NULL ; 

         E	NULL

 right table :- 
 -----------------

    SELECT E.ENAME,D.DNAME
        FROM EMP E  RIGHT OUTER JOIN DEPT D
             ON E.DEPTNO = D.DEPTNO 
     WHERE E.ENAME IS NULL ; 

	NULL	OPERATIONS
 
 both tables :- 
 -----------------

    SELECT E.ENAME,D.DNAME
        FROM EMP E  FULL OUTER JOIN DEPT D
             ON E.DEPTNO = D.DEPTNO 
     WHERE E.ENAME IS NULL
                   OR
                   D.DNAME IS NULL ; 

	E	NULL	
	NULL	OPERATIONS

ASSIGNMENT :-
-------------------------

 EMP				PROJECTS
 EMPNO  ENAME   SAL   PROJID 	PROJID  NAME  DURATION  CLIENT 
 1		       100		100	
 2		       101		101
 3		        NULL	102


1  display employee details with project details ?

2  display employee details with project detail and also display employees
    not assigned to any project ?

3  display only the projects where no employee assigned to it ? 

02-jan-24

NON EQUI JOIN :- 
-------------------------

 => non equi join is performed between the tables not sharing a common field.

 ex :- 
 
EMP				SALGRADE
EMPNO	ENAME	SAL		GRADE	LOSAL	HISAL
1	A	3000		1	700	1000
2	B	1500		2	1001	2000
3	C	4000		3	2001	3000
4	D	2500		4	3001	4000
5	E	1000		5	4001	9999

=> DISPLAY	ENAME	SAL	GRADE  ?
                                 ----------------------         -----------
                                         EMP		SALGRADE

       SELECT  E.ENAME,E.SAL,
                       S.GRADE
          FROM EMP E  JOIN SALGRADE S
               ON E.SAL BETWEEN S.LOSAL AND S.HISAL ; 

	A	3000	3
	B	1500	2
	C	4000	4
                 D	2500	3
                 E	1000	1
                
  => display grade 4 employee list ? 

        SELECT  E.ENAME,E.SAL,
                       S.GRADE
          FROM EMP E  JOIN SALGRADE S
               ON E.SAL BETWEEN S.LOSAL AND S.HISAL 
       WHERE S.GRADE = 4 ; 

 SELF JOIN :- 
 ------------------

  => joining a table to itself is called self join 
  => in self join a record in one table joined with another record of same table.
  => to perform self join the same table must be declared two times with different alias

                    	 FROM EMP X  JOIN EMP Y 
   
   	EMP X				EMP Y
	EMPNO	ENAME	MGR		EMPNO	ENAME	MGR
	7369	smith	7902		7369	smith	7902
	7499	allen	7698		7499	allen	7698
	7698	blake	7839		7698	blake	7839
	7839	king	null		7839	king	null
	7902	ford	7566		7902	ford	7566

  => DISPLAY   ENAME    MGRNAME    ? 

       SELECT X.ENAME,Y.ENAME AS MANAGER
       FROM EMP X JOIN EMP Y 
           ON  X.MGR = Y.EMPNO ; 

	smith	ford
	allen	blake
	blake	king
	
  => display employees reporting to blake ? 

    SELECT X.ENAME,Y.ENAME AS MANAGER
       FROM EMP X JOIN EMP Y 
           ON  X.MGR = Y.EMPNO  
      WHERE Y.ENAME='blake' ; 

 => blake's manager name ? 

    SELECT X.ENAME,Y.ENAME AS MANAGER
       FROM EMP X JOIN EMP Y 
           ON  X.MGR = Y.EMPNO  
      WHERE X.ENAME='blake' ; 

=> employees who are earning more than their manager ?

        SELECT X.ENAME,Y.ENAME AS MANAGER
           FROM EMP X JOIN EMP Y 
               ON  X.MGR = Y.EMPNO  
       WHERE  X.SAL > Y.SAL  ;

 => employees who are senior to their manager ? 

        SELECT X.ENAME,X.HIREDATE,
                       Y.ENAME AS MANAGER,Y.HIREDATE AS MGRHIRE
           FROM EMP X JOIN EMP Y 
               ON  X.MGR = Y.EMPNO  
       WHERE  X.HIREDATE   <    Y.HIREDATE  ;

 => 

  TEAMS
  ID	COUNTRY
 1	IND
 2	AUS
 3	ENG

=> write a query to display following output ? 

   IND  VS  AUS
   IND  VS  ENG
   AUS VS ENG

  TEAMS A			TEAMS B
  ID	COUNTRY		ID	COUNTRY
 1	IND			1	IND
 2	AUS			2	AUS
 3	ENG			3	ENG

SELECT  A.COUNTRY||'  VS  '||B.COUNTRY
FROM TEAMS A JOIN TEAMS B
     ON  A.ID < B.ID ;
 
CROSS JOIN / CARTESIAN JOIN :- 
-------------------------------------------------

=> cross join returns cross product or cartesian product of two tables 

   A  =  1,2
   B  =  3,4

  AXB  =  (1,3) (1,4) (2,3) (2,4) 

 => if cross join performed between two tables then all records of 1st table
      joined with all records of 2nd table

 => to perform cross join submit the join query without join condition.

   SELECT E.ENAME,D.DNAME
   FROM   EMP E  CROSS JOIN DEPT D ;  

  GROUP BY & JOIN :- 
  -------------------------------

  => display dept wise no of employees ? display dept names ?

      SELECT D.DNAME,COUNT(*)
         FROM EMP E  INNER JOIN DEPT D
              ON E.DEPTNO = D.DEPTNO
   GROUP BY D.DNAME ;

    EMP					DEPT
    EMPNO    ENAME   SAL   DEPTNO		DEPTNO	DNAME		LOC
    1                A             3000 10			10	ACCOUNTS	NEW YORK	
    2                B             4000 20			20	RESEARCH
    3               C             5000  30			30	SALES
    4               D             3000  20			40	OPERATIONS    
    5	    E	   2000  10

ON E.DEPTNO = D.DEPTNO :-
---------------------------------------------

 1	A	3000	ACCOUNTS
 2	B	4000	RESEARCH 
 3	C	5000	SALES
 4	D	3000	RESEARCH
 5	E	2000	ACCOUNTS

GROUP BY D.DNAME :-
--------------------------------

 ACCOUNTS	1	A	3000
		5	E	2000

 RESEARCH	2	B	4000
		4	D	3000

  SALES		3	C	5000


  SELECT D.DNAME,COUNT(*) :- 
  ---------------------------------------------

ACCOUNTS 	2
RESEARCH	2
SALES		1

=> display grade wise no of employees ? 
=> display no of employees working under each manager ?
 
03-jan-24 

 SET OPERATORS :-
 -----------------------------

 UNION
 UNION ALL
 INTERSECT
 MINUS 

 A = 1,2,3,4
 B = 1,2,5,6

 A UNION B  	= 1,2,3,4,5,6
 A UNION ALL B 	=  1,2,3,4,1,2,5,6
 A INTERSECT B	=  1,2
 A MINUS B	=   3,4
 B MINUS A	=   5,6

=> in oracle set operations performed between  records return by two queries.
 
    SELECT  STATEMENT 1
    UNION / UNION ALL / INTERSECT  /  MINUS
    SELECT STATEMENT 2 ; 

  Rules :- 

   1  no of columns return by both queries must be same
   2  corresponding columns datatype must be  same

UNION :- 
-----------

=> combines rows return by two queries
=> duplicates are eliminated
=> result is sorted 

SELECT JOB FROM EMP WHERE DEPTNO = 20 ;

CLERK
MANAGER
ANALYST
CLERK
ANALYST

SELECT JOB FROM EMP WHERE DEPTNO = 30 ;

SALESMAN
SALESMAN
SALESMAN
MANAGER
SALESMAN
CLERK

 SELECT JOB FROM EMP WHERE DEPTNO = 20
 UNION
 SELECT JOB FROM EMP WHERE DEPTNO = 30 ; 

ANALYST
CLERK
MANAGER
SALESMAN

 SELECT JOB,SAL FROM EMP WHERE DEPTNO = 20
 UNION
 SELECT JOB,SAL FROM EMP WHERE DEPTNO = 30 ; 

 ANALYST         	3000
CLERK            	800
CLERK           	1000
CLERK           	1100
MANAGER         	2900
MANAGER         	3000
SALESMAN       	 1300
SALESMAN       	 1500
SALESMAN       	 1600

=> difference between UNION  &  JOIN   ?

	UNION			JOIN 
 
1     combines rows			combines columns 
 
2    horizontal merge			vertical merge
 
3    performed between		performed between two tables 
      records return by 
      two queries

 scenario :- 

 EMP_US
 ENO	ENAME	SAL 	DNO
					 DEPT
EMP_IND					 DNO	DNAME	LOC
ENO	ENAME	SAL	DNO

=> total employees list  ? 

    SELECT * FROM EMP_US
    UNION
    SELECT * FROM EMP_IND ; 

=> employees working at US loc with dept details ? 

    SELECT  E.* , D.*
    FROM  EMP_US E  INNER JOIN DEPT D
         ON  E.DNO = D.DNO ; 

 => total employee with dept details ? 

 SELECT  E.* , D.*
    FROM  EMP_US E  INNER JOIN DEPT D
         ON  E.DNO = D.DNO   
  UNION
 SELECT  E.* , D.*
    FROM  EMP_IND E  INNER JOIN DEPT D
         ON  E.DNO = D.DNO ; 
  
UNION ALL :- 
-------------------

=> combines rows return by two queries
=> duplicates are not eliminated
=> result is not sorted 

 SELECT JOB FROM EMP WHERE DEPTNO = 20 
 UNION ALL
 SELECT JOB FROM EMP WHERE DEPTNO = 30 ; 

=> difference between UNION & UNION ALL ? 


	UNION			UNION   ALL
 
1	duplicates are eliminated            not eliminated

 2              sorts result		doesnt' sort result
 
 3             slower			faster

INTERSECT :- 
-------------------

 => returns common values

 SELECT JOB FROM EMP WHERE DEPTNO = 20 
 INTERSECT 
 SELECT JOB FROM EMP WHERE DEPTNO = 30 ; 

 CLERK
 MANAGER

MINUS :-
------------

=> returns values present in 1st query output and not present in 2nd query output 

 SELECT JOB FROM EMP WHERE DEPTNO = 20 
 MINUS
 SELECT JOB FROM EMP WHERE DEPTNO = 30 ; 
 
 ANALYST 

 SELECT JOB FROM EMP WHERE DEPTNO = 30 
 MINUS
 SELECT JOB FROM EMP WHERE DEPTNO = 20 ; 

 SALESMAN

 Question :- 
 ---------------

 T1		T2
 F1		C1
 1		1
 2		2
 3		3
10		40
20		50
30		60 

=> write outputs for the following operations ?

 1  inner join
 2  left outer 
 3 right outer
 4 full outer
 5  union 
 6  union all
 7  intersect
 8  minus

==============================================================

 SUB-QUERIES / NESTED-QUERIES :- 
 ----------------------------------------------------- 
 
 => a query in another query is called sub-query or nested query 
 => one query is called inner / child / sub-query
 => other query is called outer / parent / main query.
 => first oracle executes inner query then it executes outer query
 => output of inner query is input to outer query
 => use sub-query when where cond based on unknown value.

 Types of sub-queries :- 
 -------------------------------

 1  single-row  sub-queries 
 2  multi-row  sub-queries
 3  co-related sub-queries
 4  inline views 
 5  scalar sub-queries

 single-row sub-queries :- 
 ----------------------------------
 
 => if sub-query returns one value then it is called single-row sub-query

      SELECT COLUMNS
      FROM TABNAME
      WHERE COLNAME  OP  (SELECT STATEMENT) ;

  => OP must be any relational operator  like  >   >=    <    <=    =    <> 

   Examples :- 

   => employees earning more than blake  ? 

     SELECT *
     FROM EMP
     WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME='blake'); 
	              ---------------------------------------------------------------------
			 2900
	
 => employees who are senior to king ? 

     SELECT *
     FROM EMP
     WHERE HIREDATE <  (SELECT HIREDATE 
                                            FROM EMP 
                                             WHERE ENAME='king');

			17-NOV-81

=> name of the employee earning max salary ?

     SELECT ENAME
     FROM EMP
     WHERE SAL = MAX(SAL) ;  => ERROR

    group functions are not allowed in where clause and they are allowed only in
    select,having clauses 

      SELECT ENAME
     FROM EMP
     WHERE SAL = (SELECT MAX(SAL) FROM EMP) ;
	              ----------------------------------------------
			5000

  => name of the employee having max experience ?

     SELECT ENAME
     FROM EMP
     WHERE HIREDATE = (SELECT MIN(HIREDATE) FROM EMP) ; 

 => display 2nd max salary ? 

      SELECT MAX(SAL)
      FROM EMP
      WHERE SAL <> (SELECT MAX(SAL) FROM EMP) ; 
                                  ----------------------------------------------
                                             5000
 => name of the employee earning 2nd max sal ?
 
     SELECT  ENAME,SAL
     FROM EMP
     WHERE SAL = (  SELECT MAX(SAL)
                                 FROM EMP
                                WHERE SAL <> (SELECT MAX(SAL) FROM EMP));

=> increase the sal by 10% of the employee having max experience ? 

    UPDATE EMP
    SET SAL = SAL + (SAL*0.1)
    WHERE HIREDATE = (SELECT MIN(HIREDATE) FROM EMP) ; 

 => write a query to swap employee salaries whose empno = 7369,7499 ?

      before swap		after swap

      7369     800		7369	1600
      7499    1600		7499	800

       UPDATE EMP
       SET SAL =  CASE EMPNO
                           WHEN 7369 THEN  (SELECT SAL FROM EMP WHERE EMPNO=7499)
                           WHEN 7499 THEN  (SELECT SAL FROM EMP WHERE EMPNO = 7369)
                           END   
       WHERE EMPNO IN (7369,7499) ;

04-JAN-24  

Multi-row sub-queries :- 
--------------------------------

=> if sub-query returns more than one value then it is called multi-row sub-query

 SELECT COLUMNS
 FROM TABNAME
 WHERE COLNAME OP (SELECT STATEMENT) ; 

 => OP must be IN,NOT IN,ANY,ALL 

	 single			multi

	 =			IN

	<>			NOT IN

	>			>ANY    >ALL

	<			<ANY    <ALL

 Examples :- 

 => employees working at NEW YORK,CHICAGO locations ? 

      SELECT *
      FROM EMP
      WHERE  DEPTNO IN  (SELECT DEPTNO 
                                          FROM DEPT
                                          WHERE LOC IN ('NEW YORK','CHICAGO'));

 ANY,ALL operators :- 
-----------------------------

  => both operators are used for  >  <  comparision with multiple values

    WHERE X > ANY(1000,2000,3000)     WHERE X < ANY(1000,2000,3000) 

    IF X = 800    FALSE		IF X = 800    TRUE
              1500   TRUE                                           1500   TRUE
              4500   TRUE                                            4500  FALSE

 WHERE X > ALL(1000,2000,3000) 	WHERE X < ALL(1000,2000,3000) 

  IF X = 800   FALSE			IF X=800	TRUE
             1500 FALSE			        1500  FALSE
            4500  TRUE                                            4500 FALSE

=> employees earning more than all managers ? 

    SELECT *
    FROM EMP
    WHERE SAL >  ALL (SELECT SAL
	                     FROM EMP
                                      WHERE JOB='MANAGER');

		    3000,2900,2500

 => employees earing more than atleast one manager ?

    SELECT *
    FROM EMP
    WHERE SAL >  ANY (SELECT SAL
	                     FROM EMP
                                      WHERE JOB='MANAGER');

			3000,2900,2500

CO-RELATED SUB-QUERIES :- 
--------------------------------------------

 => if inner query references values of outer query then it is called co-related sub-query.

 => execution starts from outer query and inner query is executed no of times
      depends on no of rows return by outer query.

 => use co-related sub-query to execute sub-query for every row.

 Example :- 

 EMP
 EMPNO	ENAME	SAL	DEPTNO 
 1	A	5000	10
 2	B	3000	20 
 3	C	4000	30 
 4	D	6000	20
 5	E	3000	10

=> employees earning more than avg(sal) of organization ?

  SELECT *
  FROM EMP
  WHERE SAL > (SELECT AVG(SAL) FROM EMP )  ;

=> employees earing more than avg(sal) of their dept ? 

  SELECT *
  FROM EMP X
  WHERE SAL > (SELECT AVG(SAL) 
                            FROM EMP 
                            WHERE DEPTNO =  X.DEPTNO) ;

 1	A	5000	10     5000 > (4000)   TRUE
 2	B	3000	20     3000 > (4500)   FALSE
 3	C	4000	30     4000 > (4000)   FALSE
 4	D	6000	20     6000 >  (4500)  TRUE
 5	E	3000	10     3000 >  (4000)  FALSE

 => employees earning max sal in their dept ? 

  SELECT *
  FROM EMP X
  WHERE SAL = (SELECT MAX(SAL) 
                            FROM EMP 
                            WHERE DEPTNO =  X.DEPTNO) ;

 1	A	5000	10	5000 = (5000)   TRUE
 2	B	3000	20             3000 = (6000)   FALSE
 3	C	4000	30             4000 = (4000)  TRUE
 4	D	6000	20             6000 = (6000)  TRUE
 5	E	3000	10             3000 = (5000)  FALSE

=> display top 3 max salaries ? 

    EMP
    SAL
    5000
    1000
    3000
    2000
    2900

    SELECT   DISTINCT A.SAL
    FROM EMP A 
    WHERE 3 > (SELECT COUNT(DISTINCT B.SAL)
                         FROM EMP B
                         WHERE A.SAL < B.SAL)  
    ORDER BY SAL DESC ; 

  EMP  A		EMP B
  5000		5000	3 > (0)	TRUE
  1000		1000	3 > (4)       FALSE
  3000 		3000         3 > (1)       TRUE
  2000		2000         3 > (3)       FALSE
  2900		2900         3 > (2)       TRUE

=> display 5th max salary ?

   SELECT   DISTINCT A.SAL
    FROM EMP A 
    WHERE  (5-1) = (SELECT COUNT(DISTINCT B.SAL)
                               FROM EMP B
                               WHERE A.SAL < B.SAL)  
    ORDER BY SAL DESC ; 

 => Nth max sal ? 
 
    SELECT   DISTINCT A.SAL
    FROM EMP A 
    WHERE  (&N-1) = (SELECT COUNT(DISTINCT B.SAL)
                               FROM EMP B
                               WHERE A.SAL < B.SAL)  
    ORDER BY SAL DESC ; 

5-jan-24 

 ROWID :- 
 -------------

  => returns physical address of a row
  
       SELECT ROWID,EMPNO,ENAME,SAL FROM EMP ; 

  => rowid is called psuedo column because it is not a column but acts like a column
  => rowids are used to delete duplicate records 

  PSUEDO COLUMNS :- 
  -----------------------------

 1 ROWID
 2 ROWNUM
 3 USER
 4 LEVEL
 5 SYSDATE 

Ex :-

EMP44
EMPNO	ENAME	SAL	ROWID
1	A	5000	AAA
2	B	6000	AAB
3	C	7000	AAC
1	A	5000	AAD	
2	B	6000	AAE

DELETE FROM EMP44  WHERE ROWID  LIKE  '%AAD' ; 

DELETE FROM EMP44  WHERE ROWID  LIKE  '%AAE' ; 

=> deleting duplicates row-by-row is difficult if table contains lakhs of duplicates
     so execute the following query to delete all duplicate rows from table.

  DELETE 
  FROM EMP44 X
  WHERE ROWID <>  (SELECT MIN(ROWID)
                                     FROM EMP44
                                     WHERE EMPNO = X.EMPNO
                                                   AND
                                                   ENAME = X.ENAME
                                                   AND
                                                   SAL = X.SAL) ;

1	A	5000	AAA   <>   (AAA)     FALSE
2	B	6000	AAB   <>   (AAB)     FALSE
3	C	7000	AAC   <>   (AAC)    FALSE
1	A	5000	AAD   <>   (AAA)    TRUE	
2	B	6000	AAE   <>   (AAB)     TRUE

METHOD 2 :- 

 DELETE
 FROM EMP44  X
 WHERE ROWID  NOT IN   (SELECT MIN(ROWID)
                                             FROM EMP44
                                             GROUP BY EMPNO,ENAME,SAL) ;

		 	   AAA
		    	   AAB	
		     	   AAC

1	A	5000	AAA
2	B	6000	AAB
3	C	7000	AAC
1	A	5000	AAD	
2	B	6000	AAE

INLINE VIEWS :- 
-------------------------

  => sub-queries in from clause are called inline views 

       SELECT  COLUMNS
       FROM (SELECT  STATEMENT)   <ALIAS>
       WHERE COND ; 

  => sub-query output acts like a table for outer query.

  => INLINE views are used to control order of execution of clauses. 

  Default order :- 
  ---------------------

  FROM
  WHERE
  GROUP BY
  HAVING
  SELECT
  ORDER BY 

  => to control this order of execution use INLINE views

Example 1 :- 

 => display ranks of the employees based on sal ?

   SELECT EMPNO,ENAME,SAL,
                  DENSE_RANK() OVER (ORDER BY SAL DESC) AS RNK
   FROM EMP ; 

   above query displays ranks of all the employees but to display top 5 employees

     SELECT EMPNO,ENAME,SAL,
                  DENSE_RANK() OVER (ORDER BY SAL DESC) AS RNK
    FROM EMP 
    WHERE  RNK <= 5 ;   => ERROR 

    to overcome this use INLINE views 

    SELECT *
    FROM (SELECT EMPNO,ENAME,SAL,
                   DENSE_RANK() OVER (ORDER BY SAL DESC) AS RNK
                FROM EMP)  E
    WHERE RNK<=5 ; 

   SELECT *
   FROM E
   WHERE RNK <= 5 ; 

   => display top 3 max salaries ? 

    SELECT  DISTINCT SAL
    FROM (SELECT  SAL,
                   DENSE_RANK() OVER (ORDER BY SAL DESC) AS RNK
                FROM EMP)  E
    WHERE RNK<=3 ; 

 ROWNUM :- 
 -----------------

  => rownum returns record numbers for the records return by query
  => rownum is also a psuedo column 

     SELECT ROWNUM,EMPNO,ENAME,SAL FROM EMP ; 

	9	7839	KING	5000

     SELECT ROWNUM,EMPNO,ENAME,SAL FROM EMP WHERE SAL>=2000;

	5	7839	KING	5000
 
   => rownum is not based on table and it is based on select stmt output , if
        select stmt output changes rownum also changes.

=> display first 5 rows from emp ? 

    SELECT EMPNO,ENAME,SAL 
    FROM EMP
    WHERE ROWNUM <= 5 ; 

 => display 5th row ?  

    SELECT EMPNO,ENAME,SAL 
    FROM EMP
    WHERE ROWNUM = 5 ; 

   In where cond  with rownum   =    >   >=  will not work only  <   <=  operators works

   SELECT *
   FROM  (SELECT ROWNUM AS RNO,EMPNO,ENAME,SAL FROM EMP)  E
   WHERE RNO = 5 ; 

  WHERE RNO IN (5,7,10) ; 

  WHERE RNO BETWEEN 5 AND 10   

  WHERE MOD(RNO,2) = 0 ; 

 => last 3 rows ? 

    SELECT *
    FROM  (SELECT ROWNUM AS RNO,EMPNO,ENAME,SAL FROM EMP)  E
   WHERE  RNO >= (SELECT  COUNT(*)-2 FROM EMP) ; 

scalar sub-queries :- 
----------------------------

 => subqueries in select clause are called scalar sub-queries 

    SELECT (subquery1) , (subquery2) , -----------
    FROM tabname
    WHERE cond ; 

 => subquery output acts like a column 
 => use scalar sub-query to show the query output in seperate column

Example 1 :- 

     SELECT (SELECT COUNT(*) FROM EMP)  AS EMP,
                    (SELECT COUNT(*) FROM DEPT) AS DEPT
      FROM  DUAL ; 

06-JAN-24 

 Example 2 :- 

 => display dept wise total salary ? 

      SELECT DEPTNO,SUM(SAL) AS DEPT_TOTSAL
      FROM EMP
      GROUP BY DEPTNO ; 

   	DEPTNO 	DEPT_TOTSAL
 	--------- 	---------------------
        	30        	9600
        	10       	 8800
        	20       	10900

 => Display DEPTNO      DEPT_TOTSAL	TOTSAL   ?

      SELECT DEPTNO,SUM(SAL) AS DEPT_TOTSAL ,
                     (SELECT SUM(SAL) FROM EMP) AS TOTSAL
      FROM EMP
      GROUP BY DEPTNO ; 

  	DEPTNO 	DEPT_TOTSAL     TOTSAL
	---------- 	----------- 		----------
        	30        	9600      		29300
        	10        	8800     		29300
        	20       	10900      		29300

 => display  DEPTNO     DEPT_TOTSAL        TOTSAL    PCT   ? 

                     PCT  =  ( dept_totsal / totsal) *100

      SELECT DEPTNO,SUM(SAL) AS DEPT_TOTSAL ,
                     (SELECT SUM(SAL) FROM EMP) AS TOTSAL ,
             ROUND((SUM(SAL) /  (SELECT SUM(SAL) FROM EMP))*100 ,1) AS PCT
      FROM EMP
      GROUP BY DEPTNO ; 

select stmt
where
order by
functions
group by
joins
set operators
sub-queries

===============================================================

 DATABASE TRANSACTIONS :- 
 ------------------------------------------

 => a transaction is a unit of work that contains one or more dmls  and must be
      saved as a whole or must be cancelled as a whole.

    ex :-  money transfer

            acct1-----------------1000-----------------------> acct2
  
            update1			            update2
            (bal=bal-1000)                                            (bal=bal+1000)

            successful			           failed  	    INVALID

            failed			            successful	   INVALID

            successful			            successful	   VALID

            failed			            failed	   VALID

  => every transaction must gurantee a property called " atomocity "  
       i.e. all or none . If transaction contains multiple operations
       if all operations are successful then it must be saved , if one of the
       operation fails then entire transaction must be cancelled.

 => the following commands provided by oracle to handle transactions called
      TCL commands 

    1  COMMIT          => to save txn
    2  ROLLBACK     => to cancel txn
    3  SAVEPOINT    => to cancel part of the txn
 
 => every transaction has a begin point and an end point

 => in oracle a txn begins implicitly whenever user submits dml commands

 => a txn ends whenever user submits any of the following command

        1  COMMIT / ROLLBACK
        2  DDL COMMAND  (txn ends with COMMIT)
        3  DCL COMMAND  (txn ends with COMMIT)

 Example 1 :- 

 create table a(a number(2));
 insert into a values(10);    => txn begins T1
 insert into a values(20);
 commit ;                           => txn ends 

 Example 2 :- 

 create table a(a number(2)); => implicitly committed
 insert into a values(10);         => txn begins T1   
 insert into a values(20);
 rollback;                                 => txn ends 

  if txn ends with rollback then it is aborted txn and operations are cancelled

Example 3 :- 

 create table a(a number(2)); 
 insert into a values(10);             => txn begins T1         
 insert into a values(20);
 create table b(b number(2));    => txn ended with commit
 insert into a values(30);            => txn begins T2
 insert into a values(40);
 rollback;                                    => txn ends 

  SAVEPOINT :- 
  ------------------

  => we can declare savepoint and we can rollback upto the savepoint
  => using savepoint we can cancel part of the transaction

 create table a(a number(2)); 
 insert into a values(10);          
 insert into a values(20);
 savepoint sp1 ; 
  insert into a values(30);
 insert into a values(40);
 savepoint sp2;
 insert into a values(50);
 insert into a values(60);
 rollback to sp1 ;

 LOCKING :- 
 -----------------

  => accessing same data by no of users at the same time is called concurrent 
       access , when data accessed concurrently users encounters following problems

      1  dirty read
      2  lost update
      3  phantom read
      4  non repeatable read

   => to overcome these problem every db system supports a mechanism called
        locking mechanism

  => locks are 2 types / modes 

   1  SHARED  (S)
   2  EXCLUSIVE (X) 

 => shared lock is applied when user try to read data (select stmt).
 => exclusive lock is applied when user try to update data (dml stmt)
 
	 	S	X

  	S	YES	YES

	X	YES	NO

Example :-

             BATCH27				SYSTEM

 1  UPDATE EMP			 	2   UPDATE BATCH27.EMP
     SET SAL=2000				      SET SAL=3000
     WHERE EMPNO = 7844 ;			      WHERE EMPNO = 7844;

     locked + updated 				    ----------wait-----------------

 3   COMMIT ;				4    1  row updated 
 
      lock releases

DEADLOCK :- 
------------------

  => Deadlock is the situation where two users mutually waits for one another , if deadlock
        occurs oracle throws error so that one transaction can be cancelled and another
        can be continued.

         BATCH27				SYSTEM

 1  UPDATE EMP			 	2   UPDATE BATCH27.EMP
     SET SAL=2000				      SET SAL=3000
     WHERE EMPNO = 7369 ;			      WHERE EMPNO = 7499;


 3  UPDATE EMP			 	4    UPDATE BATCH27.EMP
     SET SAL=3000				      SET SAL=2000
     WHERE EMPNO = 7499 ;		                        WHERE EMPNO = 7369;

    ---------------------------------------------DEADLOCK--------------------------------------------------------


5    ERROR :- deadlock detected		        


6    ROLLBACK;				7     1  row updated


TABLE LEVEL LOCKING :- 
--------------------------------------

 => in table level locking all the records of the table are locked. 

              LOCK TABLE <TABNAME>  IN <MODE> ;

  EX :- 

  SQL>LOCK TABLE EMP IN EXCLUSIVE MODE ; 

 DATABASE SECURITY :- 
 ----------------------------------

 1    USERS		=> provides security at db level
 2    PRIVILEGES		=> provides security at table level
 3    VIEWS 		=> provides security at row & col level

   DATABASE  (users)
               TABLES (privileges)
                         ROWS & COLS (views)

 CREATING USER :- 
 ----------------------------

      USERNAME :- SYSTEM / TIGER

 SQL> CREATE USER NARESH IDENTIFIED BY ORACLE
           DEFAULT TABLESPACE USERS
           QUOTA UNLIMITED ON USERS ;

Granting permissions :- 
--------------------------------
 
 SQL>GRANT CREATE SESSION,CREATE TABLE TO NARESH ;

       OR

 SQL>GRANT CONNECT,RESOURCE TO NARESH ;

PRIVILEGES :- 
--------------------

=> privileges means permissions 
=> privileges are granted to user by using GRANT command

         GRANT <privileges>  ON  <tabname>  TO  <username> ;

Example 1 :-

 BATCH27 :- 
 ----------------

 SQL> GRANT ALL ON EMP TO NARESH ; 

NARESH :- 
-----------------

 SQL>SELECT * FROM BATCH27.EMP ; 
 
 SQL>UPDATE  BATCH27.EMP SET SAL=2000 WHERE EMPNO=7369;

 SQL>COMMIT ;

Example 2 :-   granting read only permission 

 BATCH27 :- 
 
SQL>GRANT SELECT ON DEPT TO NARESH ; 
 
NARESH :-

 SQL>SELECT * FROM BATCH27.DEPT ; 

 SQL>DELETE FROM BATCH27.DEPT WHERE DEPTNO=10;  => ERROR

08-jan-24 

REVOKE command :- 
-------------------------------

  => command used to take back permissions from users 

          REVOKE <privileges>  ON <tabname> FROM <usernames> ;

 Ex :- 

  BATCH27 :- 
  ----------------

  SQL>REVOKE ALL ON EMP FROM NARESH ; 

 DB Objects / ORACLE objects / SCHEMA Objects :- 
----------------------------------------------------------------------

 1  TABLES
 2  VIEWS 
 3  SYNONYMS 
 4  SEQUENCES
 5  INDEXES 

 VIEWS :- 
 --------------

 => a view is a subset of a table i.e. part of the table.

  => a view is a virtual table because it doesn't store data and doesn't occupy memory
        and it always derives data from base table.

  => a view is a representation of a query.

  => views are created 

        1  to provide security
        2  to reduce complexity

 => with the help of views we can grant specific rows & cols to users 

 => views are 2 types 

   1   simple views
   2   complex views 

 simple views :- 
 -------------------

 => a view said to be simple view if based on single table.

   CREATE VIEW <NAME>
   AS
   SELECT STATEMENT ; 

 Granting permission to create view :-  
 ------------------------------------------------

  SYSTEM :-  
 ---------------

  SQL>GRANT CREATE VIEW TO BATCH27 ; 

BATCH27 :- 
---------------

 SQL>CREATE VIEW V1
           AS
           SELECT  EMPNO,ENAME,JOB,DEPTNO  FROM EMP ; 

 => oracle creates view "V1" and stores query but not query output 

           SELECT * FROM V1 ; 

  => when the above query submitted then oracle executes the query as follows 

           SELECT * FROM (SELECT EMPNO,ENAME,JOB,DEPTNO FROM EMP) ;

 Granting permissions on view to user :- 
 ----------------------------------------------------

 BATCH27 :- 
 ----------------

 SQL>GRANT ALL ON V1 TO NARESH ;

 NARESH :- 
 --------------

 SQL>SELECT * FROM  BATCH27.V1 ; 

 SQL>UPDATE BATCH27.V1 SET JOB = 'MANAGER'  WHERE EMPNO = 7369 ; 
 
 SQL>UPDATE BATCH27.V1 SET SAL=2000 WHERE EMPNO = 7369 ;

 SQL>INSERT INTO BATCH27.V1 VALUES(999,'ABC','CLERK',20);

 ROW LEVEL SECURITY :- 
---------------------------------------

 BATCH27 :- 
-----------------

 SQL>CREATE VIEW V2
           AS
           SELECT EMPNO,ENAME,JOB,DEPTNO 
           FROM EMP
           WHERE DEPTNO = 20 ; 

 SQL>GRANT ALL ON V2 TO NARESH ; 

 NARESH :- 
 ---------------

  SQL>SELECT * FROM BATCH27.V2 ; 

  SQL>INSERT INTO BATCH27.V2 VALUES(777,'ABC','ANALYST',30);
 
   above insert command executed successfully even though it is violating where condition

 WITH CHECK OPTION :- 
 ----------------------------------

 => if view created with  "WITH CHECK OPTION" then any dml command through view
      violates where cond that dml is not accepted.

     CREATE VIEW V3
     AS
     SELECT EMPNO,ENAME,JOB,DEPTNO
     FROM EMP
     WHERE DEPTNO = 20
     WITH CHECK OPTION  ;

    GRANT ALL ON V3 TO NARESH ; 

  NARESH :- 
 -----------------

  SQL>INSERT INTO BATCH27.V3 VALUES(888,'KKK','CLERK',30);  => ERROR

 Complex views :- 
 -------------------------

  => a view said to be complex view 
 
      1  if based on multiple tables
      2  if query contains group by  clause
                                      distinct clause
                                      aggregate functions
                                      set operators
                                      sub-queries 
 
  => with the help of views complex queries can be converted into simple queries 

  Example 1  :- 

  CREATE VIEW CV1
  AS
  SELECT E.EMPNO,E.ENAME,E.SAL,
                  D.DEPTNO,D.DNAME,D.LOC
  FROM EMP E INNER JOIN DEPT D
       ON E.DEPTNO = D.DEPTNO ; 

 => after creating view whenever we want data from emp & dept tables instead of writing join
      query write the simple query

   SELECT * FROM CV1 ; 

  Example 2 :- 

   CREATE VIEW CV2 
 AS
  SELECT D.DNAME,SUM(E.SAL) AS TOTSAL
  FROM EMP E INNER JOIN DEPT D 
        ON E.DEPTNO = D.DEPTNO
  GROUP BY D.DNAME ; 

 => whenever we want dept wise total sal execute the following simple query 
 
      SELECT * FROM CV2 ; 

=> difference between simple and complex views ?


	simple				complex 

 1   based on single table			based on multiple tables 

 2   query performs simple operations                       query performs complex operations
					like joins,group by ,aggregate etc

 3   always updatable (allows dmls)		not updatable (doesn't allow dmls)

          
USER_VIEWS :- 
-----------------------

 => it is a system table that stores information about views created by user

   list of views    ? 

   SELECT VIEW_NAME FROM USER_VIEWS ; 

   query associated with v1 ? 

     SELECT TEXT FROM USER_VIEWS WHERE VIEW_NAME='V1' ; 

DROPING VIEW :- 
------------------------

  DROP VIEW V1 ; 

  if we drop table what about views created on table ? 

 ans :- views are not dropped but views cannot be queried 

 =============================================================

synonyms :- 
----------------

 => a synonym is another name or alternative name for a table or view

  => if tablename is lengthy then we can give a simple and short name to
       the table called synonym and instead of using tablename we can 
       use synonym name in SELECT/INSERT/UPDATE/DELETE queries.

             CREATE SYNONYM <NAME> FOR <TABNAME> ;

   Granting permission to create synonym :-  
   ------------------------------------------------------

   SYSTEM :-  
   ---------------

   SQL>GRANT CREATE SYNONYM TO BATCH27 ;

  BATCH27 :- 
  ----------------

  SQL>CREATE SYNONYM E FOR EMP ; 

  using synonym :- 
  -----------------------

  SQL>SELECT * FROM E ; 

  SQL>UPDATE E SET SAL=2000 WHERE EMPNO = 7369 ; 

  Accessing tables without owner name :- 
 -----------------------------------------------------

  BATCH27 :-
   ----------------

  SQL>GRANT ALL ON EMP TO NARESH ; 

  NARESH :- 
  ----------------

  SQL>SELECT * FROM BATCH27.EMP ;

  SQL>CREATE SYNONYM EMP FOR BATCH27.EMP ; 

  SQL>SELECT * FROM EMP ; 

 Question :- 
----------------

 1   CREATE SYNONYM E FOR EMP ; 
 2   SELECT * FROM EMP E ;
 3   RENAME EMP TO E ;           => changes tablename from emp to e 

  difference between  SYNONYM & ALIAS ? 

              SYNONYM				ALIAS 
 
 1         permanent				not permanent

 2         stored in db				alias is not stored in db 

 3         scope of the synonym			scope of the alias
            is upto the schema			is upto the query

USER_SYNONYMS :- 
----------------------------

 => stores list of synonyms created by user

  SQL>SELECT SYNONYM_NAME,TABLE_NAME FROM USER_SYNONYMS ;

Droping :-
------------ 
 
  SQL>DROP SYNONYM E ; 

=========================================================================

 SEQUENCES :- 
 ----------------------

 => a sequence is also a db object created to generate sequence numbers for primary key columns
 => sequences are created to auto increment column values 

  CREATE SEQUENCE <NAME> 
  [START WITH <VALUE>]
  [INCREMENT BY <VALUE>]
  [MAXVALUE <VALUE>]  
  [MINVALUE <VALUE>]
  [CYCLE/NOCYCLE]
  [CACHE <SIZE>] ; 

 Example 1 :- 
 
 CREATE SEQUENCE S1
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 5 ;

using sequence :-  
------------------------

CREATE TABLE STUDENT
(
 SID  NUMBER(2), 
 SNAME VARCHAR2(10)
);

INSERT INTO STUDENT VALUES(S1.NEXTVAL , 'A');
INSERT INTO STUDENT VALUES(S1.NEXTVAL , 'B');
INSERT INTO STUDENT VALUES(S1.NEXTVAL , 'C');
INSERT INTO STUDENT VALUES(S1.NEXTVAL , 'D');
INSERT INTO STUDENT VALUES(S1.NEXTVAL , 'E');
INSERT INTO STUDENT VALUES(S1.NEXTVAL , 'F');  => ERROR

SELECT * FROM STUDENT ; 

SID	SNAME
1	A
2	B
3	C
4	D
5	E

Example 2 :-  calling sequence in update command

 CREATE SEQUENCE S2
 START WITH 100
 INCREMENT BY 1
 MAXVALUE 999; 

 UPDATE EMP SET EMPNO = S2.NEXTVAL ; 

 Example 3 :- 

  VEHICLES
  VEHNO     	NAME 
  TS 08 AB  0001
  TS 08 AB  0002
   
 CREATE SEQUENCE S3
 START WITH 1
 INCREMENT BY 1
 MAXVALUE 9999 ;

  CREATE TABLE VEHICLES
  (
   VEHNO    VARCHAR2(10) , 
    NAME      VARCHAR2(10) 
   );

   INSERT INTO VEHICLES 
           VALUES ('TS08AB'|| TO_CHAR(S3.NEXTVAL,'0000') ,'TATA');

CYCLE / NOCYCLE :- 
--------------------------------

  => by default sequence is created with NOCYCLE.

  => if sequence created with nocycle then it starts from start with
       and generates upto to max and after reaching max then it stops.
 
 => if sequence created with cycle then after reaching max then it will be
      reset to min.

  CREATE SEQUENCE S4
  START WITH 1
  INCREMENT BY 1
  MAXVALUE 5
  MINVALUE 1
  CYCLE
  CACHE 4  ; 

 Example  4 :- 

 SQL>CREATE SEQUENCE S10 ; 

 USER_SEQUENCES :- 
 ---------------------------------

  => stores sequences created by user

  SELECT  MIN_VALUE,
                 MAX_VALUE,
                 INCREMENT_BY,
                 CYCLE_FLAG
  FROM   USER_SEQUENCES
  WHERE SEQUENCE_NAME='S10' ; 

10-JAN-24 

 INDEX :- 
 --------------

  =>  index is also a db object created to improve performance of data accessing

  => index in db is similar to index in textbook , In textbook using index
       a particular topic can be located fastly , In db using index a particular
       record can be located fastly

 => indexes are created on columns and that column is called index key

 => indexes are created on columns frequently used in where clause 

          CREATE INDEX <NAME>  ON <TABNAME>(COLNAME) ; 

  EX :- 

      	 CREATE INDEX I1 ON EMP(SAL) ; 

EMP				   3000
SAL
3000
1000			2000		         4000
5000
2000		1000 *		2500 *         4000 *            5000 *
1500		1500 *		3000 *,*
3000		2000 *
4000
2500

 => when we submit a query to oracle  it uses following methods to locate record

      1  TABLE SCAN
      2  INDEX SCAN

 => in table scan  oracle scans complete table i.e. all the records.

 => in index scan on avg oracle scans only half of the table , so index scan is
      faster than table scan.

      SELECT * FROM EMP WHERE SAL=3000 ;       (INDEX SCAN) 
      SEELCT * FROM EMP WHERE SAL>=3000 ;     (INDEX SCAN)
      SELECT * FROM EMP WHERE SAL<=3000 ;     (INDEX SCAN)

      SELECT * FROM EMP ;                                     	       (TABLE SCAN)                
      SELECT * FROM EMP WHERE ENAME='BLAKE'  ;   (TABLE SCAN)

 UNIQUE INDEX :-  
 ------------------------

  =>  unique  index doesn't allow duplicate values into the column on which 
        index is created.

       ex :-  CREATE UNIQUE INDEX  I2  ON EMP(ENAME) ; 

                    		        K

		     G                                         Q
 
                  ADAMS *           JAMES *         MARTIN *           SCOTT *
                 ALLEN *             JONES *         MILLER *            SMITH *
                 BLAKE *                                                               WARD * 

       1    SELECT * FROM EMP WHERE ENAME = 'BLAKE'  ; 

       2    INSERT INTO EMP(EMPNO,ENAME,SAL)
                         VALUES(999,'BLAKE',4000);             => ERROR

       How many ways are there to enforce uniqueness ? 

       1  declare  primary key / unique constraint
       2  create unique index 

  note :- 

  => primary key / unique columns are automatically indexed by oracle and
       oracle creates a unique index on primary key / unique columns and
       unique index doesn't allow duplicates so primary key / unique also 
       doesn't allow duplicates.

 USER_INDEXES :- 
 -------------------------

  SELECT INDEX_NAME
  FROM USER_INDEXES
  WHERE TABLE_NAME='EMP' ; 
       
Droping indexes :- 
------------------------

    DROP INDEX I1; 

  if we drop table what about indexes created on table ?

  ans :-  indexes are also dropped

 SERVER
         DATABASE
                    USER
                           TABLE
                                    ROWS & COLS
                                    CONSTRAINTS
                                    INDEXES
                                    TRIGGERS
                           VIEW
                           SYNONYM
                           SEQUENCE


creating a new table from existing table (replica) :-
----------------------------------------------------------------

 CREATE TABLE <new-tabname>
 AS
 SELECT COLUMNS
 FROM <old-tabname>
 [WHERE cond] ; 

 Example 1 :-  copying complete table

  CREATE TABLE EMP10
  AS
  SELECT * FROM EMP ;

   a  new table is created with no of rows & cols return by select query

Example 2 :-  copying specific rows & cols

 CREATE TABLE EMP11
 AS
 SELECT  EMPNO,ENAME,JOB,SAL 
 FROM EMP
 WHERE JOB IN ('CLERK','MANAGER') ;

Example 3 :-  copy only cols but not rows

  CREATE TABLE EMP12
  AS
  SELECT  * 
  FROM EMP
  WHERE 1=2 ; 

Example 4 :- copy table from one user to another user

 copy emp table from batch27 to naresh ? 

 SYSTEM :- 
 -------------

  CREATE TABLE NARESH.EMP
  AS
  SELECT * FROM BATCH27.EMP ; 

 copying data from one table to another table :- 
 --------------------------------------------------------------

  INSERT INTO <TARGET-TABLE>
  SELECT COLUMNS FROM <SOURCE-TABLE> [WHERE COND] ; 

 Ex :-

  copy data from emp to emp12 ?

  INSERT INTO EMP12
  SELECT * FROM EMP ; 
 
MERGE command :- 
-----------------------------

 => command used to merge data into a table.
 => merge is the combination of insert & update. 
 => used to manage replicas.
 => used to apply changes made to one table to another table.

  MERGE INTO <TARGET-TABLE>   <ALIAS>
  USING <SOURCE-TABLE>  <ALIAS>
  ON (CONDITION)
  WHEN MATCHED THEN 
              UPDATE
  WHEN NOT MATCHED THEN
              INSERT ; 

Example :- 

STEP 1 :-  create source table 

 CREATE TABLE CUSTS
 (
  CID   NUMBER(2),
  CNAME  VARCHAR2(10),
  CADDR  VARCHAR2(10)
  );

 INSERT INTO CUSTS VALUES(10,'A','HYD') ; 
 INSERT INTO CUSTS VALUES(11,'B','BLR') ; 

 STEP 2 :- create replica

 CREATE TABLE CUSTT 
 AS
 SELECT * FROM CUSTS ; 

 STEP 3 :- modify source table 

 INSERT INTO CUSTS VALUES(12,'C','DEL');

 UPDATE CUSTS SET CADDR = 'MUM' WHERE CID=10; 

 STEP 4 :- apply changes to replica 

  MERGE INTO CUSTT   T 
  USING CUSTS   S
  ON (S.CID = T.CID)
  WHEN MATCHED THEN
       UPDATE  SET  T.CADDR = S.CADDR  
  WHEN NOT MATCHED THEN
       INSERT  VALUES(S.CID,S.CNAME,S.CADDR) ; 

Example 2 :- 

 EMPS					EMPT
 EMPNO	ENAME	SAL 			EMPNO	ENAME	SAL
 1	A	5000 			1	A	
 2	B	6000			2	B
 3	C	7000			3	C

 => copy salaries from emps to empt ?

 1  using update command
 2  using merge command 

 update command :- 
 --------------------------

 UPDATE EMPT  T
 SET SAL = (SELECT SAL FROM EMPS WHERE EMPNO = T.EMPNO) ;
 
 =========================================================================

11-jan-24

			PL/SQL
			-----------


		PL  => procedural language

 		    	ORACLE

	           non-proc			proc

                           SQL			PL/SQL 


 Features :- 
 ---------------

1 improves performance :- 
   --------------------------------

   =>  in pl/sql ,  sql commands can be grouped into one block and we submit
         that block to oracle , so in pl/sql no of requests & response between
         user and oracle are reduced and performane is improved.

 2  supports conditional statements :- 
     ---------------------------------------------

   => supports conditional statements like IF-ELSE , so in pl/sql we can
        execute sql commands based on conditions.

 3  supports loops :- 
    -----------------------

   => supports looping statements like while,for , with the help of loops we 
        can execute statements repeatedly multiple times.

 4 supports error handling :- 
   ----------------------------------   

 =>  in pl/sql , if any statement causes error then we can handle that error
       and we can replace system generated message with our own 
       simple and user friendly message.

 5 supports reusability :- 
   ----------------------------

  =>  pl/sql programs can be stored in db and applications which are connected
        to db can reuse pl/sql programs.

 6   supports security :- 
     --------------------------

   => pl/sql provides security because pl/sql programs are stored in db , so
        only authorized users can execute the programs.

 => pl/sql blocks are 2 types 

     1 Anonymous Blocks
     2 Named Blocks
               procedures
               functions
               packages
               triggers 
 
Anonymous Blocks :- 
------------------------------

 =>  a  pl/sql program without name is called anonymous block

     DECLARE
           <declaration-part>;             optional
     BEGIN
           <executable-statements>;
     END;
        /

 how to print messages :- 
 ---------------------------------

   DBMS_OUTPUT.PUT_LINE(message);
   ---------------------- ---------------
        package           procedure

 => by default messages are not send to output , to send messages to output
      execute the following command

      SQL>SET SERVEROUTPUT ON 

Ex :- 

     BEGIN
       DBMS_OUTPUT.PUT_LINE('WELCOME');
     END;
      /

   output :- WELCOME

 How to write pl/sql programs :- 
 ----------------------------------------

 1  EDITORs
 2  IDEs

		EDITOR			IDE

   coding		yes			yes

   compilation	no			yes
 
   execution	no			yes

   debugging	no			yes

  example		notepad			sql developer

 using notepad :-  
 ---------------------

   => open notepad and enter following code

  begin
    dbms_output.put_line('hello welcome');
  end;
   /
 
  => save the program in a file as D:\NARESH\"PROG1.SQL" 
  => go to sqlplus compiled and run the program as follows

        SQL>@D:\NARESH\PROG1.SQL 

         output :- hello welcome

 Datatypes in pl/sql :-  
 ---------------------------

  1   scalar types  
  2   user define types 
  3   reference types 

 scalar types :- 
 -------------------

  => all built-in types are called scalar types 

     1   NUMBER(P) / NUMBER(P,S)
     2   CHAR/VARCHAR2/LONG/CLOB
     3   NCHAR/NVARCHAR2/NCLOB
     4   DATE/TIMESTAMP
     5   BFILE / BLOB
     6   BINARY_FLOAT / BINARY_DOUBLE
     7   BINARY_INTEGER
     8   BOOLEAN 

     1  TO  6    =>   allowed in sql , pl/sql 
     7,8            =>   allowed only in pl/sql 

 Declaring variables :- 
 ----------------------------

                    variablename          datatype(size)  ;

  ex :- 
                     n       number(4);
                     s       varchar2(10);
                     d       date;
                     b       boolean;

Assigning value to variable :- 
--------------------------------------

                      :=      =>  assignment operator

                     n  =   100 ;      => wrong

                     n  :=  100 ;      =>  right
                     s  :=  'abc' ;
                     d  :=  sysdate ; 
                     b  :=  TRUE;
 
12-jan-24 

  => write a prog to add two numbers ?

      DECLARE
          a    NUMBER(3);
          b    NUMBER(3);
          c    NUMBER(4);
     BEGIN
          a := 100;
          b := 200;
          c := a+b;
          DBMS_OUTPUT.PUT_LINE(c);
     END;
        /

    output :- 300

 How to input values at runtime :- 
 --------------------------------------------

      DECLARE
          a    NUMBER(3);
          b    NUMBER(3);
          c    NUMBER(4);
     BEGIN
          a := &a;
          b := &b;
          c := a+b;
          DBMS_OUTPUT.PUT_LINE(c);
     END;
        /

 output :- 

  enter value for a :- 500
  enter value for b :- 300

  output :- 800

 => write a prog to input date and print day of the week ?

   DECLARE
        d      DATE;
   BEGIN
        d  :=  '&date';
        DBMS_OUTPUT.PUT_LINE(TO_CHAR(d,'day')); 
   END;
      / 

  enter date :- 15-AUG-1947

  output : - friday 

=> write a prog to input name and print first name,middle name,last name ?

     DECLARE
           n         VARCHAR2(30);
           f          VARCHAR2(20);
           m        VARCHAR2(20);
           l           VARCHAR2(20);
     BEGIN
           n  := '&name' ; 
           f   :=  SUBSTR(n,1,INSTR(n,' ')-1);
           l   :=  SUBSTR(n,INSTR(n,' ',1,2)+1);
           m :=   TRIM(RTRIM(LTRIM(n,f),l));
           DBMS_OUTPUT.PUT_LINE('First Name =  '||f);
           DBMS_OUTPUT.PUT_LINE('Middle Name =  '||m);
           DBMS_OUTPUT.PUT_LINE('Last Name =  '||l);
       END;
           /

     First Name =    ???
     Middle Name =  ???
     Last Name  =  ???
 
22-JAN-24

  DB programming with PL/SQL :- 
  -----------------------------------------

   => from pl/sql to interact with db execute sql commands from pl/sql program.
   => the following commands are executed from pl/sql prog

      1 DML (insert,update,delete,merge)
      2 DQL (select)
      3 TCL  (commit,rollback,savepoint)

  SELECT stmt syntax :- 
  ------------------------------- 

  SELECT columns INTO variables
  FROM tabname
  [WHERE cond] ; 

  ex :- 

  SELECT  ename,sal INTO  n ,s 
  FROM emp 
  WHERE empno = 7844 ; 
 
 => write a prog to input empno and print name & salary ? 

      DECLARE 
            vempno       NUMBER(4);
            vname         VARCHAR2(10);
            vsal             NUMBER(7,2);
      BEGIN
             vempno := &empno;         
             SELECT  ename,sal INTO  vname,vsal
             FROM emp 
             WHERE empno = vempno; 
             DBMS_OUTPUT.PUT_LINE(vname||'    '||vsal);
      END;
         / 
       
Enter value for empno: 7566

 OUTPUT :- 

 JONES    2975

=> write a prog to input empno and print experience ?

     DECLARE
          vempno        NUMBER(4);
          vhire             DATE;
          vexpr            NUMBER(2);
    BEGIN
         vempno := &empno;
         SELECT hiredate  INTO  vhire
         FROM emp 
         WHERE empno = vempno;
         vexpr := (SYSDATE - vhire)/365;
         DBMS_OUTPUT.PUT_LINE('Experience = '||vexpr||' years');
     END;
         /

 Enter value for empno: 7499

 output :-  Experience = 43 years

 conditional statements :- 
 --------------------------------

 1  IF-THEN-ELSE
 2 MULTI IF
 3 NESTED IF

IF-THEN-ELSE :- 
------------------------

    IF  COND  THEN
          STATEMENTS;
   ELSE
          STATEMENTS;
   END IF;

MULTI IF :- 
--------------

 IF COND1 THEN
       STATEMENTS
 ELSIF  COND2 THEN
       STATEMENTS;
 ELSIF  COND3 THEN
       STATEMENTS;
 ELSE
      STATEMENTS;
 END IF;

NESTED IF :- 
-------------------

  IF  COND  THEN
         IF  COND  THEN
             STATEMENTS
         ELSE
              STATEMENTS
         END IF;
  ELSE
          STATEMENTS;
  END IF;

  => write a prog to input empno and increment sal by specific amount  and after increment
        if sal exceeds 5000 then cancel that increment ?

       DECLARE
           vempno       NUMBER(4);
           vamt            NUMBER(5);
           vsal              NUMBER(7,2);
       BEGIN
           vempno := &empno;    
           vamt      := &amount;  
           UPDATE emp SET sal = sal + vamt WHERE empno = vempno ; 
           SELECT sal INTO vsal FROM emp WHERE 	empno = vempno;
           IF vsal > 5000 THEN
                ROLLBACK;
          ELSE
               COMMIT;
          END IF;
       END;
           /

 => write a prog to  input empno and increment sal as follows  

     if  job= CLERK    incr  sal  by   10%
                 SALESMAN                  15%
                 MANAGER                   20%
                 others                           5%
      
       DECLARE
           veno       NUMBER(4);
           vjob        VARCHAR2(10);
           vpct        NUMBER(2);
      BEGIN
          veno := &empno;
          SELECT job INTO vjob FROM emp WHERE empno = veno;
          IF vjob='CLERK' THEN
             vpct := 10;
          ELSIF vjob='SALESMAN' THEN
            vpct := 15;
          ELSIF vjob='MANAGER' THEN
            vpct := 20;
          ELSE
             vpct := 5;
          END IF;
          UPDATE EMP SET SAL = SAL + (SAL*vpct/100)  WHERE EMPNO = veno;
          COMMIT;
      END;
          /

 => write a prog to input sno and calculate total,avg,result and insert into result table ?

  STUDENT
  SNO	SNAME	S1	S2	S3
  1	A	80	90	70
  2	B	30	60	40

  RESULT
  SNO	STOTAL	SAVG	SRES

  DECLARE
      vsno        NUMBER(2);
      vs1          NUMBER(3);
      vs2          NUMBER(3);
      vs3          NUMBER(3);
      vtot          NUMBER(3);
      vavg        NUMBER(5,2);
      vres         CHAR(4);
  BEGIN
       vsno := &sno;
       SELECT s1,s2,s3 INTO vs1,vs2,vs3 FROM student WHERE sno = vsno ; 
       vtot  :=  vs1 + vs2 + vs3 ; 
       vavg := vtot/3;
       IF  vs1>=35 AND vs2>=35  AND  vs3>=35 THEN
             vres := 'pass';
      ELSE
           vres := 'fail';
       END IF;
       INSERT INTO RESULT VALUES(vsno,vtot,vavg,vres);
       COMMIT;
   END;
      /


=> write a prog to process bank transaction (w/d)   ? 

 ACCOUNTS
 ACCNO	ACTYPE	BAL
 100	S	10000
 101	C	20000

 23-JAN-24 

 Loops in PL/SQL :- 
 --------------------------

 => pl/sql supports 3 types of loops 

   1  simple loop
   2  while loop 
   3  for loop 

 simple loop :- 
 ------------------

  LOOP
       statements;
       exit when cond;
  END LOOP;

  if cond = false loop continues
  if cond = true loop terminates

  while loop :- 
  ----------------

  WHILE(cond)
  LOOP
        statements;
  END LOOP;

 if cond  = true loop continues
 if cond = false loop terminates 

 for loop :- 
 -------------- 

 FOR  <var> IN <low>..<upp>
 LOOP
    statements;
 END LOOP;

 Ex :- 

 FOR i IN 1..10
 LOOP
    statements;
 END LOOP;

=>  variable "i" declared implicitly as number type
=>  by default "i" value incremented by 1
=>  scope of the "i" is upto the for loop
  
=> write a prog to print numbers from 1 to 20 ?

   using simple loop :- 
  -------------------------

  DECLARE
      x   NUMBER(2) := 1;
  BEGIN
     LOOP
          DBMS_OUTPUT.PUT_LINE(x);
          x := x+1;
          EXIT WHEN x > 20;
    END LOOP;
  END;
    /

 using while loop :- 
 ------------------------

 DECLARE
     x   NUMBER(2) := 1;
 BEGIN
     WHILE(x <= 20)
    LOOP
         DBMS_OUTPUT.PUT_LINE(x);
         x := x+1;
     END LOOP;
  END;
    / 

 using for loop :- 
 ---------------------

 BEGIN
   FOR x IN 1..10
 LOOP
     DBMS_OUTPUT.PUT_LINE(x);
 END LOOP;
 END;
   /

  BEGIN
   FOR x IN REVERSE 1..10
 LOOP
     DBMS_OUTPUT.PUT_LINE(x);
 END LOOP;
 END;
   /

=> write a prog to print 2024 calendar ? 

    01-JAN-24           ?
    02-JAN-24           ?

   31-DEC-24           ? 


    DECLARE
          d1      DATE;
          d2      DATE;
     BEGIN
          d1 := '01-JAN-24' ; 
          d2 := '31-DEC-24' ;
          while(d1<=d2)
          loop
                dbms_output.put_line(d1||'        '||to_char(d1,'day'));
                d1 := d1 + 1;
          end loop;
      END;
          /

=> write a prog to print sundays between two given dates ?

     DECLARE
          d1      DATE;
          d2      DATE;
     BEGIN
          d1 := '01-JAN-24' ; 
          d2 := '31-DEC-24' ;
          d1 := next_day(d1,'sunday');
          while(d1<=d2)
          loop
               dbms_output.put_line(d1||'        '||to_char(d1,'day'));
               d1 := d1 + 7;
          end loop;
      END;
          /

 => write a prog to input string and print following pattern ?

      input :- NARESH 

      output :- 

      N
      A
      R
      E
      S
      H

     DECLARE
        s      VARCHAR2(10);
     BEGIN
        s  :=  '&string' ; 
        for x  in 1..LENGTH(s)
      loop
           dbms_output.put_line(SUBSTR(s,x,1));
      end loop;
     END;
       /

 => write a prog to input string and print following pattern ?

     input :- NARESH

     output :- 

    N
    NA
    NAR
    NARE
    NARES
    NARESH


     DECLARE
        s      VARCHAR2(10);
     BEGIN
        s  :=  '&string' ; 
        for x  in 1..LENGTH(s)
      loop
           dbms_output.put_line(SUBSTR(s,1,x));
      end loop;
     END;
       /

  => write a prog to print following pattern ?

*
**
***
****
*****

=> write a prog to input string and print reverse of that string ?

     input :- NARESH
     output :-  HSERAN

  DECLARE
     s1    VARCHAR2(10);
     s2    VARCHAR2(10);
  BEGIN
     s1  := '&string' ; 
     for x in 1..length(s1)
     loop
         s2 := s2||substr(s1,-x,1);
     end loop;
     dbms_output.put_line(s2);
     if s1 = s2 then
          dbms_output.put_line('palindrome');
     else
          dbms_output.put_line('not a palindrome');
     end if;
 END;
  /
 
=> write a prog to input number and check whether it is prime or not ?
=> write a prog to input number and print sum of individual digits ?
=> write a prog to print prime numbers upto 100 ?
=> write a prot to input number and check whether it is arm strong number or not ?

 nested for loop :- 
 ------------------------

  BEGIN
  FOR x  IN 1..10
 LOOP
     FOR  i  IN 1..10
   LOOP
     DBMS_OUTPUT.PUT_LINE(x||' X '||i||'='||x*i);
  END LOOP;
  DBMS_OUTPUT.PUT_LINE('----------------------');
END LOOP;
 END;
   /

24-jan-24 

CURSORS :- 
------------------

 => cursors are used to process multiple rows.
 => using cursor we can access row-by-row into pl/sql program.
 => follow below steps to use cursor in pl/sql program.

   1  DECLARE CURSOR
   2  OPEN CURSOR
   3  FETCH RECORDS FROM CURSOR
   4  CLOSE CURSOR

 Declaring cursor :- 
 -----------------------

      CURSOR <NAME> IS  SELECT STATEMENT ;

EX :- 

    CURSOR C1  IS   SELECT ENAME,SAL FROM EMP ; 

 Opening cursor :- 
 -------------------------

            OPEN  <cursor-name> ; 

  ex  :-   OPEN  C1 ;

   1  select stmt declared with cursor submitted to oracle. 
   2  oracle executes the query and data returned by query is copied to cursor.
   3  c1 points to cursor

 Fetching records from cursor :- 
 -----------------------------------------

 => "FETCH" statement is used to fetch record from cursor.

       FETCH <cursor-name>  INTO  <variables> ;

 ex :- 

       FETCH C1 INTO vename,vsal ;

 =>  a fetch statement fetches one row at a time but to process multiple rows
       fetch statement should be executed multiple times , so fetch stmt should
       be in a loop.

Closing cursor :- 
-----------------------

           CLOSE  <CURSOR-NAME>;

  EX  :-  CLOSE C1 ; 

 cursor attributes :- 
 ------------------------

 1 %FOUND :- 
 ------------------

 TRUE        =>   if fetch successful
 FALSE      =>   if fetch unsuccessful

2 %NOTFOUND :- 
 -----------------------

 TRUE       =>  if fetch unsuccessful
 FALSE     =>  if fetch successful

=> write a prog to print all employee names and salaries ? 

     DECLARE
          cursor c1 is select ename,sal from emp ;
          vename  VARCHAR2(10);
          vsal         NUMBER(7,2);
     BEGIN
          open c1;
     LOOP
          fetch c1 into vename,vsal;
          exit when c1%notfound;
          dbms_output.put_line(vename||'   '||vsal);
    END LOOP;
          close c1;
    END;
        /

using while loop :- 
-----------------------

   DECLARE
          cursor c1 is select ename,sal from emp ;
          vename  VARCHAR2(10);
          vsal         NUMBER(7,2);
     BEGIN
          open c1;
          fetch c1 into vename,vsal;
          WHILE(c1%found)
     LOOP
          dbms_output.put_line(vename||'   '||vsal);
          fetch c1 into vename,vsal;
    END LOOP;
          close c1;
    END;
        /

using for loop :- 
---------------------

 FOR <var> IN <cursor-name>
 LOOP
     statements;
 END LOOP; 

 Ex :- 

 FOR r IN C1
LOOP
   statements;
END LOOP;

=> Adv of for loop is opening cursor,fetching records and closing cursor
     are done implicitly.

=> for loop is executed no of times depends on no of rows in cursor.

=> everytime for loop executed a record is fetched from cursor and assigned to
     variable "r".

=> variable "r" is also declared implicitly as rowtype.

DECLARE
   cursor c1 is select ename,sal from emp;
BEGIN
  for r in c1
 loop
     dbms_output.put_line(r.ename||'  '||r.sal);
 end loop;
END;
 /

=> write a prog to calculate total sal without using sum function ? 

     DECLARE
          cursor c1 is select sal from emp ;
          t  NUMBER(8) := 0;
    BEGIN
          for r in c1
        loop
            t  :=  t + r.sal;
        end loop;
        dbms_output.put_line(t);
    END;
       / 

25-JAN-24 

  =>  write a prog to print max salary without using max function ? 

     DECLARE
          cursor c1 is select  sal  from emp;
          m     NUMBER(5) := 0;
     BEGIN
         for r  in c1
      loop
           if   r.sal > m  then
               m := r.sal;
          end if;
      end loop;
      dbms_output.put_line(m);
     END;
        /

   DECLARE
          cursor c1 is select  sal  from emp order by sal desc ; 
          m    number(7,2);
  BEGIN
         open c1;
         fetch c1 into m;
         dbms_output.put_line(m);
         close c1;
  END;
   /

  => write a prog to print min salary without using min function ?  


=> write a prog to calculate all the students total,avg,result and insert into result table ? 

  STUDENT
  SNO	SNAME	S1	S2	S3
  1	A	80	90	70
  2	B	30	60	40

  RESULT
  SNO	STOTAL	SAVG	SRES

  DECLARE
      CURSOR  C1 IS SELECT  SNO,S1,S2,S3 FROM STUDENT ;
      vtotal    NUMBER(3); 
      vavg     NUMBER(5,2);
      vres      CHAR(4);
 BEGIN
     FOR s  IN  C1
 LOOP
      vtotal := s.s1 + s.s2 + s.s3 ; 
      vavg  := vtotal/3;
      IF s.s1>=35 AND s.s2>=35 AND s.s3>=35 THEN
            vres := 'pass';
      ELSE
           vres := 'fail';
      END IF;
      INSERT INTO result VALUES(s.sno,vtotal,vavg,vres);
 END LOOP;
      COMMIT;
END;
  / 

  => write a prog to print employee names as follows  ? 

       SMITH,ALLEN,WARD,JONES,------------------------

    DECLARE
         CURSOR C1 IS SELECT ENAME  FROM EMP ;
         s  VARCHAR2(1000);
   BEGIN
        FOR r IN C1
    LOOP
         s :=  s||r.ename||',' ; 
   END LOOP;
    DBMS_OUTPUT.PUT_LINE(RTRIM(s,','));
  END;
    /
                 
 Implicit cursor :- 
 -----------------------

  => cursor declared by oracle is called implicit cursor
  => oracle declares cursor immediately after execution of dml command.
  => implicit cursors are used to process dml commands 
  => we can find whether dml command is successful or not
  => name of the implicit cursor is SQL    

Attributes :- 
--------------

 %FOUND :- 
 ----------------

 TRUE      =>  if dml command is successful
 FALSE    =>  if dml command is unsuccessful

%NOTFOUND :- 
-----------------------

 TRUE     =>  if dml command is unsuccessful
 FALSE   =>  if dml command is successful

%ROWCOUNT :- 
-----------------------

  => returns no of rows affected by dml 

SQL%FOUND
SQL%NOTFOUND
SQL%ROWCOUNT

Ex  1  :- 

 DECLARE
     veno   NUMBER(4);
 BEGIN
     veno := &empno;
     DELETE FROM EMP WHERE EMPNO = veno;
     IF SQL%FOUND THEN
         DBMS_OUTPUT.PUT_LINE('record deleted successfully');
    ELSE
         DBMS_OUTPUT.PUT_LINE('employee does not exists');
    END IF;
 END;
   /

Ex 2 :-  write a prog for money transfer ? 

ACCOUNTS
ACCNO	ACTYPE	BAL
100	S	10000
101	S	20000

 DECLARE
   vsacno    NUMBER(4);
   vtacno     NUMBER(4);
   vamt       NUMBER(5);
   vbal         NUMBER(7);
   cnt1        NUMBER(2);
   cnt2         NUMBER(2);
 BEGIN
    vsacno := &sacno;
    vtacno := &tacno;
    vamt    := &amount;
    SELECT bal  INTO vbal FROM accounts WHERE accno = vsacno ;
    IF vamt > vbal THEN
        DBMS_OUTPUT.PUT_LINE('insufficient balance');
   ELSE
        UPDATE accounts SET bal = bal - vamt WHERE accno = vsacno; 
        cnt1 := SQL%ROWCOUNT ;
        UPDATE accounts SET bal = bal + vamt WHERE accno = vtacno; 
        cnt2 := SQL%ROWCOUNT;
        IF cnt1=1 AND cnt2=1 THEN
            COMMIT;
       ELSE
           ROLLBACK;
       END IF;
   END IF;
 END;
  /

NOTE :- 

 => if txn contains multiple operations , if all are successful then it must be committed , 
      if one of the operation fails then entire txn must be cancelled because every
      txn must gurantee a property called atomocity (all or none).

26-jan-24 

 ERROR HANDLING / EXCEPTION HANDLING :-  
 ------------------------------------------------------------------

 1 syntax errors
 2 logical errors 
 3 runtime errors 

 => errors that are raised during program execution are called runtime errors
 
  ex :-        x    number(3);

                 x := &x;   => 1000   => runtime error

 => if any statement causes runtime error then program execution is terminated
      abnormally and oracle displays error message.

 => to end the program normally and to replace system generated message
      with our own simple and user friendly message then we need to handle
      runtime error

 => to handle runtime errors include a block called EXCEPTION block.

      DECLARE
           declaration-part;
      BEGIN
          execution-part;        =>  stmts causes exception
      EXCEPTION
         error handling -part;  => stmts handles exception
      END;
        /

 => if any statement causes runtime error then control is transferred to 
      exception block and executes the statements in exception block.

 => exceptions are 2 types 

   1  system defined
   2  user defined 

system defined :- 
-----------------------

=> errors raised by oracle are called system defined exceptions 

 1  ZERO_DIVIDE :- 
    ------------------------ 

  => raised when we try to divide a number with 0. 

          a  := &a;    10
          b  := &b;    0
          c  := a/b;     => zero_divide error

 2   VALUE_ERROR :- 
    --------------------------

   => raised when variable type or size mismatches

           x   number(3);

           x := &x;   => 1000  => value_error

3  NO_DATA_FOUND :- 
 --------------------------------

 => raised when data not found in the table

           veno := &empno;  => 9090

          SELECT ename INTO vename 
          FROM emp 
          WHERE empno = veno ; => no_data_found error

4  TOO_MANY_ROWS :-  
    -------------------------------

  => raised when select fetches more than one row

             vdno := &dno; => 20 
 
            SELECT ename INTO vename
            FROM emp 
            WHERE deptno = vdno ;  => too_many_rows error

 5  DUP_VAL_ON_INDEX :- 
     ---------------------------------

   => raised when we try to insert duplicate value into primary key column 

       create table abc(a  number(2) primary key);
       insert into a values(10);
       insert into a values(10);   => dup_val_on_index error

 example 1 :- 

 DECLARE
   a   NUMBER(3);
   b   NUMBER(3);
   c   NUMBER(4);
BEGIN
   a := &a;
   b := &b;
   c := a/b;
   DBMS_OUTPUT.PUT_LINE(c);
EXCEPTION
  WHEN VALUE_ERROR THEN
        DBMS_OUTPUT.PUT_LINE('value exceeding limit');
  WHEN ZERO_DIVIDE THEN
        DBMS_OUTPUT.PUT_LINE('divisor cannot be zero');
END;
 /

Enter value for a: 10
Enter value for b: 0

OUTPUT :- 
divisor cannot be zero

2 write a prog to input empno and print name & salary ? 

  DECLARE
       veno   NUMBER(4);
       vename  VARCHAR2(10);
       vsal     NUMBER(7,2);
  BEGIN
        veno := &empno;
        SELECT ename,sal INTO vename,vsal 
         FROM emp 
         WHERE empno=veno;
         DBMS_OUTPUT.PUT_LINE(vename||'  '||vsal);
 EXCEPTION
         WHEN NO_DATA_FOUND THEN
              DBMS_OUTPUT.PUT_LINE('invalid empno');
          WHEN OTHERS THEN
              DBMS_OUTPUT.PUT_LINE('unknown error');
   END;
    /

3  

  create table emp55
  (
   empno  number(4) primary key,
   ename  varchar2(10) not null,
   sal         number(7,2) check(sal>=3000)
  );

 write a prog to insert data into emp55 table ? 

 DECLARE
    veno               NUMBER(4);
    vename          VARCHAR2(10);
    vsal                 NUMBER(7,2);
 BEGIN
    veno := &empno;
    vename := '&ename';
    vsal   := &sal;
    INSERT INTO emp55 VALUES(veno,vename,vsal);
 EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
         DBMS_OUTPUT.PUT_LINE('empno should not be duplicate');
    WHEN OTHERS THEN
         IF SQLCODE = -2290 THEN
                 DBMS_OUTPUT.PUT_LINE('sal >= 3000');
         END IF;
 END;
  /

27-JAN-24 

 USER DEFINED EXCEPTIONS :- 
 ---------------------------------------------

  => exceptions raised by user are called user defined exceptions 
  => user defined exceptions raised by user by using

      1 RAISE statement
      2 RAISE_APPLICATION_ERROR

 using raise statement :- 
 --------------------------------

          RAISE  <exception-name> ;

    ex  :-    RAISE abc ; 

  => exception "abc" must be declare in declaration part  as 

                abc   exception ; 

 example :- 

  DECLARE
   a   NUMBER(3);
   b   NUMBER(3);
   c   NUMBER(4);
   ONE_DIVIDE  EXCEPTION;
BEGIN
   a := &a;
   b := &b;
   IF b=1 THEN
       RAISE ONE_DIVIDE;
  END IF;
   c := a/b;
   DBMS_OUTPUT.PUT_LINE(c);
EXCEPTION
   WHEN ZERO_DIVIDE THEN
           DBMS_OUTPUT.PUT_LINE('divisor cannot be zero');
   WHEN ONE_DIVIDE THEN
         DBMS_OUTPUT.PUT_LINE('divisor cannot be one');
  WHEN OTHERS THEN
         DBMS_OUTPUT.PUT_LINE('unknown error');
END;
 /

using raise_application_error :- 
----------------------------------------

             RAISE_APPLICATION_ERROR(error code,error msg);

                      error code  =>  -20001 to -20999
   
  => difference between raise & raise_application_error  ?

     1  in raise stmt  exception is raised by using name but in raise_application_error
         exception is raised by using code.

     2  use raise stmt  to raise exception and to handle exception and use 
         raise_application_error  to raise exception but do not want to handle it.

  Example 1 :- 

  => write a prog to increment specific employee sal by specific amount 
       and sunday updates are not allowed ?

      DECLARE
          veno  NUMBER(4);
          vamt  NUMBER(5);
     BEGIN
         veno := &empno;
         vamt := &amount;
         IF TO_CHAR(SYSDATE,'DY') = 'SUN' THEN
             RAISE_APPLICATION_ERROR(-20001,'sunday not allowed');
         END IF;
         UPDATE emp SET sal = sal + vamt WHERE empno = veno;
         COMMIT;
    END;
      /
 
Example 2 :- 

 ACCOUNTS
 ACCNO	ACTYPE	BAL
100	S	10000
101	S	20000

=> write a prog for money withdrawl ? 

  DECLARE
        vacno    NUMBER(4);
        vamt     NUMBER(5);
        vbal       NUMBER(7);
 BEGIN
       vacno := &acno;  
       vamt  := &amount;   
       SELECT bal INTO vbal FROM accounts WHERE accno = vacno;
       IF vamt > vbal THEN
            RAISE_APPLICATION_ERROR(-20002,'insufficient balance');
       END IF;
       UPDATE accounts SET bal = bal - vamt WHERE accno = vacno  ;
       COMMIT;
EXCEPTION
        WHEN NO_DATA_FOUND THEN
              RAISE_APPLICATION_ERROR(-20001,'account does not exists');
END;
 /


NAMED PL/SQL BLOCKS :- 
-------------------------------------

procedures
functions
packages
triggers 

SUB-PROGRAMS :- 
--------------------------

 PROCEDURES
 FUNCTIONS 
 
Advantages :- 
------------------

 1 modular programming :- 
  -----------------------------------

  => with the help of procedures & function a big pl/sql program can be divided into small modules

2  reusability :- 
 -------------------

 => procs/funcs are stored in db , so applications which are connected to db can reuse 
      procs/funcs.

3  invoked from front-end :- 
   ---------------------------------

  => procs/funcs can be called from front-end applications like java/.net/python etc.

4 improves performance :- 
  ----------------------------------

 => proc/func improves performance because they are precompiled i.e. when we create a 
      procedure program is compiled and stored in db and whenever we call procedure
      only execution is repeated but not compilation ,so this improves performance.

 PROCEDURES :- 
 -------------------------

  => a procedure is a named pl/sql block that accepts some input and performs some action
       on db and may or may not returns a value. 

 => procedures are created to perform one or more dml operations on tables.

 CREATE OR REPLACE PROCEDURE <name>
 (
    parameters if any
 )
 IS
    <declaration-part>;
BEGIN
     statements;
END;
 /

29-jan-24

parameters :- 
-----------------

 => we can declare parameters and we can pass values to parameters 
 => parameters are 3 types 

   1  IN
   2  OUT
   3  IN OUT

  => "in" parameter always receives value from main program.
  => "out" parameter always sends value to main program.
  => " in out " parameter receives and sends value

 example 1 :- procedure without parameters

 => create procedure to increment all employee salaries by 1000 ?

      CREATE OR REPLACE PROCEDURE raise_salary
      IS
      BEGIN
         UPDATE EMP SET SAL=SAL+1000 ;
         COMMIT;
     END;
        /

 procedure created (compiled + stored in db)

 Execution :- 
 ----------------

  1   SQL prompt
  2   another pl/sql prog
  3   front-end applications 

 executing from sql prompt :- 
 ------------------------------------

     EXECUTE  procname ; 

 ex :- 

 SQL>EXECUTE raise_salary ; 

example 2 :- procedure with parameters 

 => create procedure to increment specific employee sal by specific amount ?

     CREATE OR REPLACE  PROCEDURE raise_salary 
     (
         peno IN  NUMBER ,
         pamt IN  NUMBER
      )
     IS
     BEGIN
          UPDATE EMP SET SAL = SAL + pamt WHERE EMPNO  = peno; 
          COMMIT;
     END;
        /

  Execution :- 
  -----------------

  EXECUTE  raise_salary (7499,1000); 

 Example 3 :- procedure with out parameter

 create procedure to increment specific employee sal by specific amount 
 and after increment if send the updated sal to calling program ?

   CREATE OR REPLACE  PROCEDURE raise_salary 
     (
         peno IN  NUMBER ,
         pamt IN  NUMBER,
         pnewsal OUT NUMBER
      )
     IS
     BEGIN
          UPDATE EMP SET SAL = SAL + pamt WHERE EMPNO  = peno; 
          COMMIT;
          SELECT SAL INTO pnewsal FROM EMP WHERE EMPNO = peno;
   END;
     /

    procedure created (compiled + stored in db)

Execution :- 
---------------

 SQL>VARIABLE K NUMBER
 SQL> EXECUTE RAISE_SALARY(7499,1000,:K);
 SQL> PRINT :K
         K
    ----------
      4600

=> create a procedure that accepts name and returns first name,middle name,last name ?

   CREATE OR REPLACE PROCEDURE  splitName
   (
     pname  IN VARCHAR2,
     pfname  OUT VARCHAR2,
     pmname  OUT  VARCHAR2,
     plname     OUT  VARCHAR2
   )
   IS
   BEGIN
           pfname  :=  SUBSTR(pname,1,INSTR(pname,' ')-1);
           plname   :=  SUBSTR(pname,INSTR(pname,' ',1,2)+1);
           pmname :=   TRIM(RTRIM(LTRIM(pname,pfname),plname));
   END;
     /

 => write a prog to input name and print first , middle ,last name ? 

     DECLARE
        n   VARCHAR2(30);
        f    VARCHAR2(20);
       m   VARCHAR2(20);
       l     VARCHAR2(20);
    BEGIN
          n := '&name';
          splitName(n,f,m,l);
          DBMS_OUTPUT.PUT_LINE('First Name = '||f);
          DBMS_OUTPUT.PUT_LINE('Middle Name = '||m);
          DBMS_OUTPUT.PUT_LINE('Last Name = '||l);
   END;
     /

Declaring parameters with default value :- 
--------------------------------------------------------

 => a parameter can be declared with default value as follows 

              pamt  IN NUMBER  DEFAULT   500

 => while executing procedure if we do not pass value to parameter then oracle assigns default value

    CREATE OR REPLACE  PROCEDURE raise_salary 
     (
         peno IN  NUMBER ,
         pamt IN  NUMBER DEFAULT 500,
         pnewsal OUT NUMBER
      )
     IS
     BEGIN
          UPDATE EMP SET SAL = SAL + pamt WHERE EMPNO  = peno; 
          COMMIT;
          SELECT SAL INTO pnewsal FROM EMP WHERE EMPNO = peno;
   END;
     /

EXECUTION :- 

 SQL>VARIABLE K NUMBER

 SQL>EXECUTE raise_salary(peno=>7499,pnewsal=>:K);

 SQL>EXECUTE raise_salary(peno=>7499,pamt=>1000,pnewsal=>:K);

  => create a procedure for money withdrawl ?

  => create a procedure for money deposit ?

  => create a procedure for money transfer ?

 CREATE OR REPLACE PROCEDURE TRANSFER
 (
    psacno  IN  NUMBER,
    ptacno   IN  NUMBER,
    pamt     IN  NUMBER
 )
 IS
  vbal    NUMBER;
 BEGIN
    SELECT bal INTO vbal FROM ACCOUNTS WHERE ACCNO = psacno;
    IF pamt > vbal THEN 
        RAISE_APPLICATION_ERROR(-20001,'insufficient balance');
   END IF;
   UPDATE ACCOUNTS SET BAL = BAL  - pamt WHERE ACCNO = psacno;
   UPDATE ACCOUNTS SET BAL = BAL  + pamt WHERE ACCNO = ptacno;
   COMMIT;
 END;
 /

30-jan-24 

 USER DEFINE FUNCTIONS :- 
 ------------------------------------------

  => when predefine functions not meeting our requirements then we create
       our own functions called user define functions.

  => a function is also a named pl/sql block that accepts some input performs
       some calculation and must return a value.

  => functions are created 

        1 for calculations
        2 to fetch value from db

 CREATE OR REPLACE FUNCTION <NAME>
 (
   parameters if any 
 )  RETURN <type>	 
 IS
      declaration-part; 
 BEGIN
      statements;
      RETURN <expr>;
 END;
   /

 Example 1 :- 

  CREATE OR REPLACE FUNCTION  CALC
  (
     a   NUMBER,
     b   NUMBER,
     op CHAR
  )  RETURN NUMBER
  IS
  BEGIN
        IF op = '+' THEN
           RETURN (a+b);
        ELSIF op = '-' THEN
           RETURN(a-b);
        ELSIF op = '*' THEN
           RETURN(a*b);
        ELSE
           RETURN(a/b);
        END IF;
  END;
    /    

EXECUTION :- 
--------------------

 1  sql commands
 2  another pl/sql prog
 3  front-end applications 

executing from select command :- 
------------------------------------------------

  SQL>SELECT  CALC(10,20,'*') FROM DUAL ;   => 200

  SQL>SELECT ENAME,SAL,COMM,
                         CALC(SAL,NVL(COMM,0),'+') AS TOTSAL 
           FROM EMP ;

 Example 2 :- 

 => create a function to check whether year is leap year or not ?

     CREATE OR REPLACE FUNCTION IS_LEAP
     (
         y  NUMBER
      ) RETURN VARCHAR2
     IS
        d  DATE;
     BEGIN
            d  :=  TO_DATE('29-FEB-'||y);
            RETURN 'leap year' ;
     EXCEPTION
           WHEN OTHERS THEN
                 RETURN 'not a leap year';
     END;
        /

Execution :- 

  SQL>SELECT  IS_LEAP(2024) FROM DUAL ;   => LEAP YEAR

  SQL>SELECT IS_LEAP(2023) FROM DUAL ;   => NOT A LEAP YEAR

  SQL> SELECT ENAME,HIREDATE,
                     IS_LEAP(EXTRACT(YEAR FROM HIREDATE)) AS LEAP
            FROM EMP ;

Example 3 :- 

 => create function that accepts deptno and returns names of the employees
      working for that dept ? 

              INPUT       :-     DEPTNO = 20 

              OUTPUT    :-   SMITH,JONES,SCOTT,ADAMS,FORD

    CREATE OR REPLACE FUNCTION getNames
    (
       pdno  NUMBER
    ) RETURN VARCHAR2
    IS
        CURSOR C1 IS SELECT  ENAME FROM EMP WHERE DEPTNO = pdno ;
        s  VARCHAR2(1000);
    BEGIN
        FOR r IN C1
    LOOP
         s :=  s||r.ename||',' ;
    END LOOP;
    RETURN RTRIM(s,',');
    END;
     /
  
EXECUTION :- 
 
SQL>SELECT  getNames(20) FROM DUAL ; 

SQL>SELECT DEPTNO,getNames(DEPTNO) AS NAMES
         FROM EMP
         GROUP BY DEPTNO ;

=> create a function to return total amount of particular order ?

 ORDERS				  PRODUCTS
 ordid    prodid	qty 		  prodid	pname	price
 1000    100	 2		  100	A	1000
 1000    101	 3		  101	B	1500
 1000    102	 1		  102	C	2000
 1001    100	 2
 
           INPUT   :-   ordid    =  1000

           OUTPUT  :-   amount  =  8500

 => difference between procedures & functions  ?

               PROCEDURE		FUNCTION 

1     may or may not returns a value           must return a value
 
2     can return multiple values		always returns one value

3    returns value using out parameter        returns value using return statement

4    cannot be executed from sql                 can be executed from sql commands
      commands

 5   created to perform one or                     created for calculations or to fetch value from db
      more dml operations 

 6   create procedure to                              create function to get balance
      update balance

USER_SOURCE :- 
--------------------------

 => stores list of procedures & functions created by user

  NAME		TYPE		LINE	TEXT
  IS_LEAP  	FUNCTION	1	FUNCTION IS_LEAP
 				2	(
				3	  y  NUMBER
				4	)
				5	IS

    SELECT DISTINCT NAME,TYPE
    FROM USER_SOURCE ;

   SELECT TEXT
   FROM USER_SOURCE
   WHERE NAME='IS_LEAP' ;

31-JAN-24 

PACKAGES :- 
-------------------

 => a package is a collection of procedures & functions.
 => related procedures & functions are grouped into one package.
 
 Advantages :- 
 ------------------

 1 easy to manage :- 
   ------------------------

  => because related procedures & functions available in single package so managing is easy

 2 supports overloading :- 
    ------------------------------

  => standalone proc/func doesn't support overloading but package supports overloading, 
       In package we can define two or more proc/func with same name with different parameters.

 3 supports hiding :- 
   -------------------------

  => by default proc/func are public they can be called from any application connecte to oracle 
       but in package we can make members as public & private , public members can be
       called from any prog but private members can be called with in package.

 4  improves performance :- 
     ---------------------------------

 => from application prog if we request for a package member then oracle not only loads
      requested member but entire package loaded into memory  and subsequent requests
      will not go to db and no of requests going to db are reduced and performance is improved.

 => package contains 2 parts 

    1 package specification
    2 package body 

 package specification :- 
 -------------------------------

 => package specifcation contains declarations of procedures & functions.

 CREATE OR REPLACE PACKAGE <NAME>
 AS
 PROCEDURE <NAME>(PARAMETERS) ;
 FUNCTION <NAME> (PARAMETERS) RETURN TYPE ;
 --------------
END;
 /

package body :- 
----------------------

 => package body contains definitions of procedures & functions 

 CREATE OR REPLACE PACKAGE BODY <NAME>
 AS
 PROCEDURE <NAME> (PARAMETERS) 
 IS
 BEGIN
   STATEMENTS ;
 END <PROCNAME>;
  FUNCTION <NAME> (PARAMETERS) RETURN TYPE
  IS
  BEGIN
         STATEMENTS;
  END <FUNNAME>;
  -------------

  END;
   /

Example :- 

 create package to implement following operations ?
 
 1  hire employee (proc)
 2  fire employee  (proc)
 3  raise salary     (proc)
 4  calculate experience (func)
 5  return top N employees based on sal  (func)

 package specification :- 
 --------------------------------

 CREATE OR REPLACE PACKAGE HR
 AS
 PROCEDURE HIRE(E NUMBER,N VARCHAR2,J VARCHAR2,S NUMBER,D NUMBER) ;
 PROCEDURE FIRE(E NUMBER);
 PROCEDURE RAISE_SALARY(E NUMBER,AMT NUMBER); 
 FUNCTION EXPR(E NUMBER)  RETURN NUMBER;
 FUNCTION TOPN(N NUMBER)  RETURN SYS_REFCURSOR;
 END;
  /

package body :- 
----------------------

 CREATE OR REPLACE PACKAGE BODY HR 
 AS
 PROCEDURE HIRE(E NUMBER,N VARCHAR2,J VARCHAR2,S NUMBER,D NUMBER) 
 IS
 BEGIN
     INSERT INTO EMP(EMPNO,ENAME,JOB,SAL,DEPTNO,HIREDATE)
            VALUES(E,N,J,S,D,SYSDATE);
     COMMIT;
END HIRE; 
PROCEDURE FIRE(E NUMBER)
IS
BEGIN
   DELETE FROM EMP WHERE EMPNO = E;
   COMMIT;
END FIRE;
PROCEDURE RAISE_SALARY(E NUMBER,AMT NUMBER)
IS
BEGIN
     UPDATE EMP SET SAL = SAL + AMT WHERE EMPNO = E;
     COMMIT;
END RAISE_SALARY;
FUNCTION EXPR(E NUMBER)  RETURN NUMBER
IS
  vhire  DATE; 
  vexpr  NUMBER(2);
BEGIN 
   SELECT HIREDATE INTO vhire FROM EMP WHERE EMPNO = E;
   vexpr :=  (SYSDATE-vhire)/365 ; 
   RETURN vexpr; 
END EXPR ;
FUNCTION TOPN(N NUMBER) RETURN SYS_REFCURSOR
IS
C1  SYS_REFCURSOR;
BEGIN
   OPEN C1 FOR SELECT *
                            FROM (SELECT EMPNO,ENAME,SAL,
                                           DENSE_RANK() OVER (ORDER BY SAL DESC) AS RNK 
                                      FROM EMP) 
                             WHERE RNK <= N;  	
   RETURN C1;
END TOPN;
END;
 /

EXECUTION :- 

 SQL>EXECUTE HR.HIRE(100,'ABC','CLERK',4000,20);

 SQL>EXECUTE HR.RAISE_SALARY(100,1000);

 SQL>SELECT HR.EXPR(7369) FROM DUAL ; 

 SQL>SELECT HR.TOPN(3) FROM DUAL ; 

 => create package to implement variour bank transactions ? 

 ACCOUNTS
 ACCNO	ACTYPE	BAL 

 TRANSACTIONS
 TRID	TTYPE	TDATE	TAMT	ACCNO

CREATE SEQUENCE S1
START WITH 1
INCREMENT BY 1
MAXVALUE 99999 ; 

1 account opening (proc)
2 account closing  (proc)
3 money deposit   (proc)
4 money withdrawl (proc)
5 money transfer  (proc )
6 balance enquiry (func)
7 statement between two given dates  (func)
8 latest N transactions of particular customer (func)

CREATE OR REPLACE PACKAGE BANK
AS
PROCEDURE OPEN_ACCT(A NUMBER,T CHAR,B NUMBER);
PROCEDURE CLOSE_ACCT(A NUMBER);
FUNCTION GETBAL(A NUMBER) RETURN NUMBER;
PROCEDURE CREDIT(A NUMBER,AMT NUMBER);
PROCEDURE DEBIT(A NUMBER,AMT NUMBER);
PROCEDURE TRANSFER(S NUMBER,T NUMBER,AMT NUMBER);
FUNCTION GETSTAT(A NUMBER,S DATE,E DATE)  RETURN SYS_REFCURSOR;
FUNCTION GETSTAT(A NUMBER,N NUMBER) RETURN SYS_REFCURSOR;
END;
 /

CREATE OR REPLACE PACKAGE BODY BANK
AS
PROCEDURE OPEN_ACCT(A NUMBER,T CHAR,B NUMBER)
IS
BEGIN
    INSERT INTO ACCOUNTS VALUES(A,T,B);
    COMMIT;
END OPEN_ACCT ; 
PROCEDURE CLOSE_ACCT(A NUMBER)
IS
BEGIN
    DELETE FROM ACCOUNTS WHERE ACCNO=A;
    COMMIT;
END CLOSE_ACCT;
FUNCTION  GETBAL(A  NUMBER) RETURN NUMBER
IS
VBAL  NUMBER;
BEGIN
  SELECT BAL INTO VBAL FROM ACCOUNTS WHERE ACCNO=A;
  RETURN VBAL;
END GETBAL;
PROCEDURE CREDIT(A NUMBER,AMT NUMBER)
IS
BEGIN
   UPDATE ACCOUNTS SET BAL=BAL + AMT WHERE ACCNO=A;
   INSERT INTO TRANSACTIONS VALUES(S1.NEXTVAL,'D',SYSDATE,AMT,A);
   COMMIT;
END CREDIT;
PROCEDURE DEBIT(A NUMBER,AMT NUMBER)
IS
BEGIN
     IF AMT > GETBAL(A) THEN
          RAISE_APPLICATION_ERROR(-20001,'insufficient balance');
    END IF;
   UPDATE ACCOUNTS SET BAL=BAL - AMT WHERE ACCNO=A;
   INSERT INTO TRANSACTIONS VALUES(S1.NEXTVAL,'W',SYSDATE,AMT,A);
   COMMIT;
END DEBIT;
PROCEDURE TRANSFER(S NUMBER,T NUMBER,AMT NUMBER)
IS
BEGIN
    DEBIT(S,AMT);
    CREDIT(T,AMT);
END TRANSFER;
FUNCTION GETSTAT(A NUMBER,S DATE,E DATE) RETURN SYS_REFCURSOR
IS
C1  SYS_REFCURSOR;
BEGIN
    OPEN C1 FOR  SELECT *
                              FROM TRANSACTIONS 
                              WHERE ACCNO = A
                                            AND
                                          TDATE BETWEEN  S AND  E ;
   RETURN C1;
END GETSTAT;
FUNCTION GETSTAT(A NUMBER,N NUMBER) RETURN SYS_REFCURSOR
IS
C1  SYS_REFCURSOR;
BEGIN
  OPEN C1 FOR SELECT *
                           FROM ( SELECT *
                                         FROM TRANSACTIONS
                                          WHERE ACCNO =  A
                                         ORDER BY TDATE DESC)
                            WHERE ROWNUM <= N ;
 RETURN C1;
END GETSTAT;
END;
/

Droping :- 
---------------

 SQL> DROP PACKAGE  HR ;   =>  drops package specification & body

 SQL>DROP PACKAGE BODY BANK ;  => drops only package body 

 dbms_output.put_line()
 ----------------- -----------
 package        proc

===============================================================

TRIGGERS :- 
-------------------

 => a trigger is also a named pl/sql block like procedure but executed implicitly
      by oracle whenever user submits DML/DDL commands.

 => triggers are created 

      1  to control dmls 
      2  to enforce complex rules and validations
      3  to audit day-to-day operations on tables
      4  to manage replicas
     
 CREATE OR REPLACE TRIGGER <NAME>
 BEFORE / AFTER  INSERT OR UPDATE OR DELETE 
 ON <TABNAME>
 [FOR EACH ROW]
 [
    DECLARE
         VARIABLES;
 ]
 BEGIN
        STATEMENTS;
 END;
   /

       
BEFORE triggers :- 
-------------------------- 

 => if triggers is before then oracle executes the trigger before executing dml

AFTER triggers :- 
------------------------

 => if trigger is after then oracle executes the trigger after executing dml

Trigger Levels :- 
----------------------

1  statement level (default)
2  row level 

=> statement level triggers are executed once per the statement
=> row level triggers are executes once per the row affected by dml
 
Examples :-

=> create trigger to not to allow dmls on emp table on sunday ?

CREATE OR REPLACE TRIGGER T1
BEFORE INSERT OR UPDATE OR DELETE
ON EMP
BEGIN
     IF TO_CHAR(SYSDATE,'DY') = 'SUN' THEN
           RAISE_APPLICATION_ERROR(-20001,'sunday not allowed');
     END IF;
 END;
  /

02-jan-24 

=> create trigger to not to allow dmls on emp table as follows ?

          mon - fri       <10am  and  >4pm
          sat               <10am and >2pm
          sun              ------------------------

     CREATE OR REPLACE TRIGGER T2
     BEFORE  INSERT OR UPDATE OR DELETE
     ON EMP
     BEGIN
           IF TO_CHAR(SYSDATE,'D')  BETWEEN 2 AND 6 THEN          
              IF   TO_CHAR(SYSDATE,'HH24') < 10
                    OR
                    TO_CHAR(SYSDATE,'HH24') >= 16 THEN
                          RAISE_APPLICATION_ERROR(-20001,'only between 10am and 4pm');
              END IF;
           ELSIF TO_CHAR(SYSDATE,'DY')='SAT' THEN
                    IF TO_CHAR(SYSDATE,'HH24') < 10
                         OR
                         TO_CHAR(SYSDATE,'HH24') >= 14 THEN
                               RAISE_APPLICATION_ERROR(-20001,'only between 10am and 2pm');
                    END IF;
            ELSIF TO_CHAR(SYSDATE,'DY')='SUN'  THEN
                       RAISE_APPLICATION_ERROR(-20001,'sunday not allowed');
            END IF;
      END;
        /


Testing :-
-------------

 SQL>UPDATE EMP SET COMM = 500 WHERE EMPNO = 7566;  => ERROR


=> create trigger to not to allow to update empno ? 

  CREATE OR REPLACE TRIGGER T3
  BEFORE UPDATE OF EMPNO
  ON EMP
  BEGIN
       RAISE_APPLICATION_ERROR(-20001,'empno cannot be updated');
 END;
  / 

Testing :-
------------
 
SQL>UPDATE EMP SET EMPNO=9999 WHERE EMPNO=7566 ; => ERROR

:OLD , :NEW variables :- 
----------------------------------

 =>  these two variables are called bind variables
 => these two variables stores records affected by dml 
 => record user trying to insert is copied to :NEW variable.
=>  record user is trying to delete is copied to :OLD variable
=> record user is trying to update is copied to both :OLD, :NEW variables

 INSERT INTO EMP VALUES(100,'A','CLERK',4000,---) ;  =>  :NEW
						EMPNO ENAME JOB        SAL
						100        A            CLERK   4000

UPDATE EMP SET SAL=5000 WHERE EMPNO=100 ;   =>     :OLD
						   EMPNO		SAL
						    100		4000

						  :NEW
						   EMPNO		SAL	
						   100		5000

 DELETE FROM EMP WHERE EMPNO = 100   ;             =>       :OLD
					                    EMPNO  ENAME    SAL
						   100          A               5000

=> these two variables are allowed in row level triggers but not allowed in statement level triggers 


=> create trigger to not to allow to decrement salary ? 

     CREATE OR REPLACE TRIGGER T4
     BEFORE UPDATE
     ON EMP
     FOR EACH ROW
     BEGIN
            IF :NEW.SAL < :OLD.SAL THEN
                 RAISE_APPLICATION_ERROR(-20001,'sal cannot be decremented');
            END IF;
     END;
        /

  Testing :-  
 ----------------
 
 SQL> UPDATE EMP SET SAL=1000 WHERE EMPNO = 7788 ; => ERROR

=> create trigger to insert details into emp_resign when employee resigns from organization ?

 EMP_RESIGN
 EMPNO	ENAME	JOB    SAL   HIREDATE    DOR 

 CREATE TABLE EMP_RESIGN
 (
  EMPNO  NUMBER(4),
  ENAME  VARCHAR2(10),
  JOB        VARCHAR2(10),
   SAL       NUMBER(7,2),
  HIREDATE DATE,
  DOR        DATE
 );

CREATE OR REPLACE TRIGGER T5
AFTER DELETE
ON EMP
FOR EACH ROW
BEGIN
    INSERT INTO EMP_RESIGN
           VALUES (:OLD.EMPNO,:OLD.ENAME,:OLD.JOB,:OLD.SAL,:OLD.HIREDATE,SYSDATE);
END;
 /

Testing :- 
--------------

 SQL>DELETE FROM EMP WHERE EMPNO = 7369 ; 

 SQL>SELECT * FROM EMP_RESIGN ; 

 => create trigger to not to allow more than 4 employees per dept ? 

   EMP44
   ENO	DNO
   1	10
   2	10
   3	10
   4	10
   5	10   => NOT ALLOWED


  CREATE OR REPLACE TRIGGER T6
  BEFORE  INSERT
  ON EMP
  FOR EACH ROW
  DECLARE
         X   NUMBER;
  BEGIN
         SELECT COUNT(*) INTO X  FROM EMP44 WHERE DNO = :NEW.DNO ; 
         IF X=4 THEN
                RAISE_APPLICATION_ERROR(-20001,'max 4 emps per dept');
         END IF;
   END;
    /

 Testing :- 
 ---------------

  INSERT INTO EMP44  VALUES(1,10); 
  INSERT INTO EMP44  VALUES(2,10); 
  INSERT INTO EMP44  VALUES(3,10); 
  INSERT INTO EMP44  VALUES(4,10); 
  INSERT INTO EMP44  VALUES(5,10);  => ERROR

03-feb-24

Auditing :- 
---------------

=> Auditing means monitoring day-to-day activities on tables. 
=> Triggers are created to audit tables.
 
 EMP_AUDIT
 UNAME   OPERATION    OPTIME   NEW_ENO    NEW_ENAME   NEW_SAL   OLD_ENO    OLD_ENAME    OLD_SAL

 CREATE TABLE EMP_AUDIT
 (
   UNAME           VARCHAR2(20),
   OPERATION   VARCHAR2(10),
   OPTIME          TIMESTAMP,
   NEW_ENO     NUMBER(4),
   NEW_ENAME   VARCHAR2(10),
   NEW_SAL          NUMBER(7,2),
   OLD_ENO     NUMBER(4),
   OLD_ENAME   VARCHAR2(10),
   OLD_SAL          NUMBER(7,2)
   );

  CREATE OR REPLACE TRIGGER T7
  AFTER INSERT OR UPDATE OR DELETE
  ON EMP
  FOR EACH ROW 
  DECLARE
       OP   VARCHAR2(10);
  BEGIN
        IF INSERTING THEN
             OP := 'INSERT' ;
        ELSIF UPDATING THEN
            OP := 'UPDATE';
        ELSE
            OP := 'DELETE';
        END IF;
        INSERT INTO EMP_AUDIT
             VALUES(USER,OP,SYSDATE,:NEW.EMPNO,:NEW.ENAME,:NEW.SAL,
                                                     :OLD.EMPNO,:OLD.ENAME,:OLD.SAL);
 END;
   /


Testing :- 
------------

1  INSERT INTO EMP(EMPNO,ENAME,SAL) VALUES(888,'ABC',4000);

2   UPDATE EMP SET SAL=5000 WHERE EMPNO = 888 ;        

3   DELETE FROM EMP WHERE EMPNO = 888; 

   SELECT * FROM EMP_AUDIT ; 

 
    how many triggers can be created on table ? 

   ANS :- 12 

  what is the order of execution of triggers ? 

  before stmt
  before row
  after row
  after stmt 

 compound trigger :-  
 --------------------------

  => using compound trigger we can define multiple triggers in one trigger.
  => introduced in 11g ver
 
 CREATE OR REPLACE TRIGGER T8
 FOR UPDATE
 ON EMP
 COMPOUND TRIGGER

  BEFORE STATEMENT IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('before stmt');
  END BEFORE STATEMENT;

  BEFORE EACH ROW IS
  BEGIN
       DBMS_OUTPUT.PUT_LINE('before row');
  END BEFORE EACH ROW;

  AFTER EACH ROW IS
  BEGIN
        DBMS_OUTPUT.PUT_LINE('after row');
  END AFTER EACH ROW;

  AFTER STATEMENT IS
  BEGIN
       DBMS_OUTPUT.PUT_LINE('after stmt');
  END AFTER STATEMENT;
END  ;
/

USER_TRIGGERS :- 
--------------------------

  SELECT TRIGGER_NAME,
                 TRIGGER_TYPE,
                 TRIGGERING_EVENT
  FROM USER_TRIGGERS
  WHERE TABLE_NAME='EMP' ;

Droping trigger :- 
-----------------------

 DROP TRIGGER T1 ;

 if we drop table what about triggers created on table ?
 
 ans :- triggers are also dropped

 server
         database
                   user
                         tables
                                   rows & cols
                                   constraints
                                   indexes
                                   triggers 
                         views
                         synonyms
                         sequences
                         procedures
                         functions
                         packages

Dynamic SQL :- 
---------------------

 => sql commands generated at runtime are called dynamic sql commands

     ex :-    DROP  TABLE  EMP ;   (static sql command) 

          
                tname   VARCHAR2(20);
                tname := '&tabname'  ; 
                DROP TABLE tname ;   => (Dynamic sql command)

  => Dynamic sql is useful when we don't know table names and column names until runtime.

  => use EXECUTE IMMEDIATE to execute DDL commands or Dynamic SQL commands.

        syntax :-   EXECUTE IMMEDIATE  '  DDL / DYNAMIC SQL COMMAND ' 

  Ex 1 :- 

 declare  
      tname   VARCHAR2(20);
begin
    tname := '&tabname'  ; 
    EXECUTE IMMEDIATE   ' DROP TABLE   ' ||tname;
end;
  /

05-feb-24

=> create a procedure to drop table ?

  CREATE OR REPLACE PROCEDURE  DROP_TABLE
  (
     tname   VARCHAR2
  )
  IS
  BEGIN
       EXECUTE IMMEDIATE  ' DROP TABLE  '||tname;
  END;
     /

Execution :-

 SQL>EXECUTE   DROP_TABLE('STUDENT');

=> create procedure to drop all tables ?

    CREATE OR REPLACE PROCEDURE DROP_ALL_TABLES
    IS
     CURSOR C1 IS SELECT TABLE_NAME FROM USER_TABLES ;
    BEGIN
       FOR R IN C1
    LOOP
        EXECUTE IMMEDIATE  'DROP TABLE '||R.TABLE_NAME||'  CASCADE CONSTRAINTS';
    END LOOP;
    END;
      /
 
 EXECUTION :- 

  SQL>EXECUTE  DROP_ALL_TABLES ; 

 => write a prog to print no of rows in all tables ?

      EMP     ??
      DEPT  ??
      STUDENT  ??
  
   DECLARE
        CURSOR C1 IS SELECT TABLE_NAME FROM USER_TABLES;
        S   VARCHAR2(500);
        CNT  NUMBER(4);
   BEGIN
       FOR  R IN C1
    LOOP
          S  := ' SELECT  COUNT(*) FROM '||R.TABLE_NAME ;
          EXECUTE IMMEDIATE  S  INTO CNT;
          DBMS_OUTPUT.PUT_LINE(R.TABLE_NAME||'   '||CNT);
    END LOOP;
   END;
     /

  UTL_FILE package :- 
  -----------------------------

  =>  predefined package used to work with files
  =>  using this package we can create new files , write data and read data from files.
 
 members of utl_file package :- 
 ---------------------------------------

 1  FILE_TYPE :-  It is a datatype used to declare file variable 
 2  FOPEN        :-  it is a function used to open file 
 3  PUT_LINE   :-  it is a procedure used to write data into file 
 4  GET_LINE   :-  it is a procedure used to read data from file
 5  FCLOSE      :-  it is a procedure used to close file

 creating directory object :- 
 ---------------------------------

 => a directory object points to operating system directory.
 => created by dba and granted to users 
 
  SYSTEM :- 
  ---------------

  SQL>CREATE DIRECTORY D10 AS 'D:\NARESH' ;

  SQL>GRANT READ,WRITE ON DIRECTORY D10 TO BATCH27 ;

  creating  file and writing data into file :- 
  --------------------------------------------------

  DECLARE
        f1   UTL_FILE.FILE_TYPE;
  BEGIN
        f1 := UTL_FILE.FOPEN('D10','abc.txt','w');
        UTL_FILE.PUT_LINE(f1,'hello');
        UTL_FILE.PUT_LINE(f1,'welcome');
        UTL_FILE.PUT_LINE(f1,'UTL_FILE package');
         UTL_FILE.FCLOSE(f1);
   END;
     /

 reading data from file :- 
 ------------------------------

 DECLARE
        f1   UTL_FILE.FILE_TYPE;
        s    VARCHAR2(500);
  BEGIN
        f1 := UTL_FILE.FOPEN('D10','abc.txt','r');
    LOOP
        UTL_FILE.GET_LINE(f1,s); 
        DBMS_OUTPUT.PUT_LINE(s);
   END LOOP;
   EXCEPTION
           WHEN NO_DATA_FOUND THEN
                       UTL_FILE.FCLOSE(f1);
   END;
     /
 
 copy data from oracle table to file :- 
 -----------------------------------------------

 DECLARE
      f1   UTL_FILE.FILE_TYPE;
     S  VARCHAR2(500);
      CURSOR C1 IS SELECT EMPNO,ENAME,SAL FROM EMP;
  BEGIN
        f1 := UTL_FILE.FOPEN('D10','emp.txt','W');
        FOR R IN C1 
   LOOP
        S  := R.EMPNO||','||R.ENAME||','||R.SAL;
        UTL_FILE.PUT_LINE(f1,S);
   END LOOP;
       UTL_FILE.FCLOSE(f1);
  END;
   /


DECLARE
      f1   UTL_FILE.FILE_TYPE;
     S  VARCHAR2(500);
      CURSOR C1 IS SELECT EMPNO,ENAME,SAL FROM EMP;
  BEGIN
        f1 := UTL_FILE.FOPEN('D10','emp.csv','W');
        FOR R IN C1 
   LOOP
        S  := R.EMPNO||','||R.ENAME||','||R.SAL;
        UTL_FILE.PUT_LINE(f1,S);
   END LOOP;
       UTL_FILE.FCLOSE(f1);
  END;
   /

copying data from file to oracle table :- 
----------------------------------------------------

 CREATE TABLE EMP88
 (
  EMPNO  NUMBER(4),
  ENAME VARCHAR2(10),
  SAL   NUMBER(7)
);

 DECLARE
     f1  UTL_FILE.FILE_TYPE;
     S   VARCHAR2(500);
     veno     NUMBER(4);
     vename  VARCHAR2(10);
     vsal      NUMBER(7,2);
BEGIN
     f1 := UTL_FILE.FOPEN('D10','emp.csv','r');
   LOOP
        UTL_FILE.GET_LINE(f1,S);
        veno :=  REGEXP_SUBSTR(S,'[^,]+',1,1);
        vename :=   REGEXP_SUBSTR(S,'[^,]+',1,2);
        vsal      := REGEXP_SUBSTR(S,'[^,]+',1,3);
        INSERT INTO EMP88 VALUES(veno,vename,vsal);
  END LOOP;
  EXCEPTION
        WHEN NO_DATA_FOUND THEN
               UTL_FILE.FCLOSE(f1);
  END;
  /

 S = 7369,SMITH,800

      REGEXP_SUBSTR(string,pattern,start,occurance) 

     REGEXP_SUBSTR(S,'[^,]+',1,1);

06-feb-24 

 How to store images in DB :- 
 --------------------------------------

 1 BFILE (Binary File Large Object)
 2 BLOB (Binary Large Object)

using BFILE :- 
------------------

=> BFILE is called external lob because lob is stored outside db and db stores path (locator).
=> to insert locator use BFILENAME function.

                  BFILENAME(dir obj,file name)

 example :- 

  CREATE TABLE cities
  (
     name   varchar2(20),
     photo    BFILE
  );

 INSERT INTO cities VALUES('Agra',BFILENAME('D10','taj.jpeg'));


 using BLOB :- 
 -------------------
 
 => BLOB is called internal lob because lob stored inside db.
 
 example :- 

 CREATE TABLE cities
 (
    name  varchar2(20),
    photo  BLOB
 );

 INSERT INTO cities VALUES('Hyd',EMPTY_BLOB());

=> create a procedure to update photo ?

  CREATE OR REPLACE PROCEDURE UPDATE_PHOTO 
  (
     n  IN VARCHAR2,
     f   IN  VARCHAR2 
   )
  IS
      s   BFILE;
      t    BLOB;
      x   NUMBER;
 BEGIN
     s  := BFILENAME('D10',f);
     SELECT photo INTO t FROM cities WHERE name = n  FOR UPDATE ; 
     DBMS_LOB.OPEN(s,DBMS_LOB.LOB_READONLY);
     x := DBMS_LOB.GETLENGTH(s);
     DBMS_LOB.LOADFROMFILE(t,s,x);
     UPDATE cities SET photo = t WHERE name = n;
     COMMIT;
     DBMS_LOB.CLOSE(s);
 END;
  /

execution :- 

  SQL>SELECT LENGTH(PHOTO) FROM CITIES WHERE NAME='Hyd' ; => 0

  SQL> EXECUTE UPDATE_PHOTO('Hyd','charminar.jpg');

  SQL>SELECT LENGTH(PHOTO) FROM CITIES WHERE NAME='Hyd' ; => 7497

 
CREATE OR REPLACE PROCEDURE BLOB_TO_FILE
(
  n IN VARCHAR2,
  f IN VARCHAR2
)
IS
  l_file      UTL_FILE.FILE_TYPE;
  l_buffer    RAW(32767);
  l_amount    BINARY_INTEGER := 32767;
  l_pos       INTEGER := 1;
  l_blob      BLOB;
  l_blob_len  INTEGER;
BEGIN
  -- Get LOB locator
  SELECT photo
  INTO   l_blob
  FROM  cities
  WHERE name=n;

  l_blob_len := DBMS_LOB.getlength(l_blob);
  
  -- Open the destination file.
  
  l_file := UTL_FILE.fopen('D10',f,'wb', 32767);

  -- Read chunks of the BLOB and write them to the file
  -- until complete.
  WHILE l_pos <= l_blob_len 
 LOOP
    DBMS_LOB.read(l_blob, l_amount, l_pos, l_buffer);
    UTL_FILE.put_raw(l_file, l_buffer, TRUE);
    l_pos := l_pos + l_amount;
  END LOOP;
  
  -- Close the file.
  UTL_FILE.fclose(l_file);
  
EXCEPTION
  WHEN OTHERS THEN
         UTL_FILE.fclose(l_file);
END;
/

=========================================================================
 
07-FEB-24 			

Normalization :- 
----------------------

 => Normalization is process of decomposing table with redundency into number of well
       structured tables.

 => Normallization is set of rules called normal forms  and  there are six normal forms 

     1NF
     2NF
     3NF
     BCNF (boyce-codd NF)
     4NF
     5NF

Example :- 

BILL
BILLNO    BDATE  CCODE   CNAME   ADDR     ICODE   NAME  RATE   QTY   VALUE    TBILL
1	07          100	A          HYD       1
				          2
				          3


				          20

=> above table contains redundency , so to reduce redundency apply normal forms 

1NF :- 
--------

 => a table said to be in 1NF  if there are no multi valued attributes in it or all the attributes
      in table are atomic (single).

 BILL
 BILLNO    BDATE  CCODE   CNAME   ADDR     ICODE   NAME  RATE   QTY   VALUE    TBILL
 S               S          S               S            S              M          M          M         M        M            S

=> in the above table some attributes are single valued and some attributes are multi valued
     so table is not according to 1NF then decompose the table as follows

BILL
BILLNO    BDATE   CCODE   CNAME   ADDR     TBILL
-----------
1	07           100	A          HYD
2	07           101            B          HYD

BILL_ITEMS
BILLNO   ICODE    NAME    RATE    QTY    VALUE
----------------------
 1            1	A         100
 1            2
 1            3
 2            1               A          100
 2            2
 3            1               A           100


=> in the above table , if  ICODE is repeated  NAME,RATE are also repeated , so to reduce
     this redundency apply 2NF.

2NF :- 
--------

 =>  a table said to be in 2NF

    1  if it is in 1NF
    2  if there are no partial dependencies in it

partial dependency :- 
----------------------------

 => if non key field depends on part of the key then it is called partial dependency

 R(A,B,C,D)           A   =>  pk

  A  -----> B,C,D   (full dependency)

 R(A,B,C,D)          A,B  =>  pk

  A,B ------> C    (full dependency)

     B --------> D   (partial dependency)


TABLE 1 :- 

 BILL
 BILLNO    BDATE   CCODE   CNAME   ADDR     TBILL
 -----------
 
=> above table according to 2NF because no partial dependencies exists in the table

TABLE 2 :- 

BILL_ITEMS
BILLNO   ICODE    NAME    RATE    QTY    VALUE
----------------------

  BILLNO,ICODE  ---------> QTY , VALUE  (full dependency)
                ICODE ---------> NAME,RATE    (partial dependency)

=> above table contains partial dependency  , so the table is not according to 2NF then
     decompose the table as follows 
 
TABLE 2 :-

  ITEMS
  ICODE   NAME   RATE
  ----------

 TABLE 3 :-

 BILL_ITEMS
 BILLNO   ICODE   QTY   VALUE
 ----------------------

 3NF :- 
 --------

  => a table said to be in 3NF

  1  if it is in 2NF 
  2  if there are no transitive dependencies in it

 transitive dependency :- 
 ------------------------------

 => if non key field depends on another non key field then it is called transitive dependency

 R(A,B,C,D)      A   => pk 

 A ------->B,C   (full dependency)

 C --------> D   (transitive dependency)
 
 TABLE 1 :- 

 BILL
 BILLNO    BDATE   CCODE   CNAME   ADDR     TBILL
 -----------

  BILLNO   ----------> BDATE  , TBILL   (full dependency)

  CCODE  ------------> CNAME,ADDR  (transitive dependency)

 => above table contains transitive dependecy , so the table is not according to 3NF then
      decompose the table as follows 

 CUST
 CCODE	CNAME	ADDR
 -----------

BILL
BILLNO  BDATE    TBILL     CCODE
----------
 
 TABLE 2 :- 
---------------

  ITEMS
  ICODE   NAME   RATE
  ----------

 TABLE 3 :- 
 --------------

 BILL_ITEMS
 BILLNO   ICODE   QTY   VALUE
 ----------------------

AFTER 3NF :- 
-------------------

CUST
CCODE	CNAME	ADDR
-----------

BILL
BILLNO   BDATE    TBILL     CCODE  (FK)
----------

ITEMS
ICODE     NAME    RATE
---------

BILL_ITEMS
BILLNO    ICODE    QTY    VALUE
------------------------










 























 





















































  


 


























     











 

 
 















 














 


















 
























 



























 
 



 




























 






 









































       


















   











































                    

  
 












 



































 





















 





















































 






















































 
























                               



  





 

  










































































































      













    




































































































































































 


 



















	






















 














































































































+


































































































 










  
 














































\




















































































 













 

































































 










































 


















































































































 


































































































































































 

     



































   












 












